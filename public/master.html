<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FantaGTS - Master Control</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            min-height: 100vh;
            color: #e2e8f0;
            padding: 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .section {
            background: rgba(255,255,255,0.08);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .section h2 {
            margin-bottom: 15px;
            color: #4299e1;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 8px;
            font-size: 1.3em;
        }

        .status-card {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .status-active { 
            border-left-color: #48bb78; 
            background: rgba(72, 187, 120, 0.1);
        }
        .status-waiting { 
            border-left-color: #ed8936; 
            background: rgba(237, 137, 54, 0.1);
        }
        .status-error { 
            border-left-color: #f56565; 
            background: rgba(245, 101, 101, 0.1);
        }

        .big-display {
            font-size: 3em;
            text-align: center;
            font-weight: bold;
            color: #4299e1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 20px 0;
        }

        .rounds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .round-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .round-btn.available {
            background: #48bb78;
            color: white;
            border-color: #48bb78;
        }

        .round-btn.active {
            background: #f56565;
            color: white;
            animation: pulse 2s infinite;
            border-color: #f56565;
        }

        .round-btn.completed {
            background: #4a5568;
            color: #a0aec0;
            cursor: not-allowed;
            border-color: #4a5568;
        }

        .round-btn:hover:not(.completed):not(.active) {
            background: #38a169;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-primary {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }

        .btn-primary:hover {
            background: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }

        .btn-danger {
            background: #f56565;
            color: white;
            border-color: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.4);
        }

        .btn-warning {
            background: #ed8936;
            color: white;
            border-color: #ed8936;
        }

        .btn-warning:hover {
            background: #dd6b20;
            box-shadow: 0 4px 12px rgba(237, 137, 54, 0.4);
        }

        .btn:disabled {
            background: #4a5568;
            cursor: not-allowed;
            transform: none;
            border-color: #4a5568;
            color: #a0aec0;
        }

        .participants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .participant-card {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4299e1;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .participant-card.bid-confirmed {
            border-left-color: #48bb78;
            background: rgba(72, 187, 120, 0.15);
        }

        .participant-card.bid-pending {
            border-left-color: #ed8936;
            background: rgba(237, 137, 54, 0.15);
        }

        .participant-card.offline {
            border-left-color: #4a5568;
            opacity: 0.6;
        }

        .current-round-display {
            background: rgba(245, 101, 101, 0.2);
            border: 3px solid #f56565;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
        }

        .live-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #f56565;
            border-radius: 50%;
            animation: blink 1s infinite;
            margin-right: 8px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #4299e1;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            color: #cbd5e0;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: #48bb78;
        }

        .notification.error {
            background: #f56565;
        }

        .notification.warning {
            background: #ed8936;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            color: #e2e8f0;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .results-table th,
        .results-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-size: 0.9em;
        }

        .results-table th {
            background: rgba(0,0,0,0.3);
            font-weight: bold;
            color: #4299e1;
        }

        .bid-status {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 4px;
            margin-top: 5px;
        }

        .bid-confirmed {
            background: #48bb78;
            color: white;
        }

        .bid-pending {
            background: #ed8936;
            color: white;
        }

        .bid-none {
            background: #4a5568;
            color: #a0aec0;
        }
</style>

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ FantaGTS - Master Control</h1>
            <p>Pannello di controllo per gestire aste e monitorare il torneo</p>
            <div id="serverStatus" class="status-card status-active">
                <span class="live-indicator"></span>
                Server attivo - Connesso
            </div>
        </div>

        <!-- Dashboard Principale -->
        <div class="dashboard-grid">
            <!-- Controllo Aste -->
            <div class="section">
                <h2>üéØ Controllo Aste</h2>

                <div id="currentRoundInfo" class="current-round-display" style="display: none;">
                    <h3>Round Attivo: <span id="activeRoundName">M1</span></h3>
                    <div class="big-display" id="offersDisplay">0/0</div>
                    <p id="offersStatusMessage">In attesa delle offerte dei partecipanti</p>
                </div>

                <div class="rounds-grid">
                    <button class="round-btn available" data-round="M1">M1</button>
                    <button class="round-btn available" data-round="M2">M2</button>
                    <button class="round-btn available" data-round="M3">M3</button>
                    <button class="round-btn available" data-round="M4">M4</button>
                    <button class="round-btn available" data-round="M5">M5</button>
                    <button class="round-btn available" data-round="M6">M6</button>
                    <button class="round-btn available" data-round="M7">M7</button>
                    <button class="round-btn available" data-round="F1">F1</button>
                    <button class="round-btn available" data-round="F2">F2</button>
                    <button class="round-btn available" data-round="F3">F3</button>
                </div>

                <div style="margin-top: 20px;">
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center;">
                        <strong>Round selezionato: <span id="selectedRoundDisplay">Nessuno</span></strong>
                    </div>
                    <button class="btn btn-primary" id="btnAvviaRound" onclick="avviaRoundSelezionato()" disabled>
                        üöÄ Avvia Round Selezionato
                    </button>
                    <button class="btn btn-danger" id="btnFermaRound" onclick="forzaFineRound()" disabled>
                        ‚èπÔ∏è Forza Fine Round
                    </button>
                </div>
            </div>

            <!-- Stato Partecipanti -->
            <div class="section">
                <h2>üë• Partecipanti Connessi</h2>
                <div id="participantsContainer">
                    <p>Nessun partecipante connesso</p>
                </div>
            </div>

            <!-- Statistiche Live -->
            <div class="section">
                <h2>üìä Statistiche Live</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="statConnessi">0</div>
                        <div class="stat-label">Connessi</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="statOfferte">0</div>
                        <div class="stat-label">Offerte</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="statRounds">0</div>
                        <div class="stat-label">Round Completati</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="statCrediti">0</div>
                        <div class="stat-label">Crediti Spesi</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Risultati Ultimo Round -->
        <div class="section">
            <h2>üèÜ Risultati Ultimo Round</h2>
            <div id="lastRoundResults">
                <p>Nessun round completato ancora</p>
            </div>
        </div>

        <!-- Squadre in Formazione -->
        <div class="section">
            <h2>üë• Squadre in Formazione</h2>
            <div id="squadreInFormazione">
                <p>Nessuna squadra ancora formata</p>
            </div>
        </div>

        <!-- Strumenti Admin -->
        <div class="section">
            <h2>üîß Strumenti Amministrazione</h2>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                <button class="btn btn-primary" onclick="vaiASetup()">
                    ‚öôÔ∏è Configurazione
                </button>
                <button class="btn btn-primary" onclick="esportaDati()">
                    üìä Esporta Dati
                </button>
                <button class="btn btn-primary" onclick="mostraClassifica()">
                    üèÜ Classifica
                </button>
                <button class="btn btn-warning" onclick="resetAste()">
                    üîÑ Reset Aste
                </button>
                <button class="btn btn-danger" onclick="resetTotale()">
                    ‚ö†Ô∏è Reset Totale
                </button>
            </div>
        </div>
    </div>

    <!-- Modal Risultati Round -->
    <div id="resultsModal" class="modal">
        <div class="modal-content">
            <h3 id="resultsTitle">Risultati Round</h3>
            <div id="resultsContent"></div>
            <button class="btn btn-primary" onclick="closeModal('resultsModal')" style="margin-top: 20px;">
                Chiudi
            </button>
        </div>
    </div>

    <!-- Modal Classifica -->
    <div id="classificaModal" class="modal">
        <div class="modal-content">
            <h3>üèÜ Classifica Generale</h3>
            <div id="classificaContent"></div>
            <button class="btn btn-primary" onclick="closeModal('classificaModal')" style="margin-top: 20px;">
                Chiudi
            </button>
        </div>
    </div>

    <!-- Modal Conferma -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h3 id="confirmTitle">Conferma Azione</h3>
            <p id="confirmMessage">Sei sicuro di voler procedere?</p>
            <div style="margin-top: 20px; text-align: right;">
                <button class="btn btn-secondary" onclick="closeModal('confirmModal')">Annulla</button>
                <button class="btn btn-primary" id="confirmBtn">Conferma</button>
            </div>
        </div>
    </div>

    <script>
        // Variabili globali
let socket;
let gameState = {
    fase: 'waiting',
    roundAttivo: null,
    asteAttive: false,
    connessi: [],
    ultimiRisultati: null
};
let roundSelezionato = null;
let participantsBids = new Map(); // Traccia le offerte dei partecipanti

// NUOVO: Sistema di persistenza per Master
const MASTER_STORAGE_KEYS = {
    GAME_STATE: 'fantagts_master_game_state',
    COMPLETED_ROUNDS: 'fantagts_completed_rounds',
    LAST_UPDATE: 'fantagts_last_update'
};

// NUOVA FUNZIONE: Salva stato completo del gioco
async function saveMasterState() {
    try {
        // Raccogli tutti i dati necessari dal server
        const [squadre, partecipanti, risultatiPartite, classifica] = await Promise.all([
            fetch('/api/squadre').then(r => r.json()).catch(() => []),
            fetch('/api/partecipanti').then(r => r.json()).catch(() => []),
            fetch('/api/risultati-partite').then(r => r.json()).catch(() => []),
            fetch('/api/classifica').then(r => r.json()).catch(() => [])
        ]);

        // Ottieni tutti i risultati delle aste per round
        const rounds = ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'F1', 'F2', 'F3'];
        const astePerRound = {};
        
        for (const round of rounds) {
            try {
                const response = await fetch(`/api/aste-round/${round}`);
                if (response.ok) {
                    astePerRound[round] = await response.json();
                }
            } catch (error) {
                console.log(`Round ${round} non ancora completato`);
                astePerRound[round] = [];
            }
        }

        const masterStateData = {
            gameState: gameState,
            squadre: squadre,
            partecipanti: partecipanti,
            risultatiPartite: risultatiPartite,
            classifica: classifica,
            astePerRound: astePerRound,
            roundsCompletati: rounds.filter(r => astePerRound[r].length > 0),
            timestamp: new Date().getTime()
        };

        localStorage.setItem(MASTER_STORAGE_KEYS.GAME_STATE, JSON.stringify(masterStateData));
        localStorage.setItem(MASTER_STORAGE_KEYS.LAST_UPDATE, new Date().getTime().toString());
        
        console.log('‚úÖ Stato Master salvato:', masterStateData);
    } catch (error) {
        console.error('‚ùå Errore salvataggio stato Master:', error);
    }
}

// NUOVA FUNZIONE: Carica stato salvato del Master
async function loadMasterState() {
    try {
        const savedState = localStorage.getItem(MASTER_STORAGE_KEYS.GAME_STATE);
        const lastUpdate = localStorage.getItem(MASTER_STORAGE_KEYS.LAST_UPDATE);
        
        if (!savedState || !lastUpdate) {
            console.log('Nessuno stato Master salvato trovato');
            return false;
        }

        // Controlla se lo stato non √® troppo vecchio (7 giorni)
        const now = new Date().getTime();
        const savedTime = parseInt(lastUpdate);
        const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 giorni

        if (now - savedTime > maxAge) {
            console.log('Stato Master scaduto, rimuovo dati salvati');
            clearMasterState();
            return false;
        }

        const parsedState = JSON.parse(savedState);
        console.log('üìä Stato Master caricato:', parsedState);

        // Ripristina stato del gioco
        gameState = parsedState.gameState || gameState;
        
        // Ripristina rounds completati
        if (parsedState.roundsCompletati) {
            parsedState.roundsCompletati.forEach(round => {
                const btn = document.querySelector(`[data-round="${round}"]`);
                if (btn) {
                    btn.classList.remove('active', 'available');
                    btn.classList.add('completed');
                    btn.disabled = true;
                    btn.style.opacity = '0.6';
                    btn.style.pointerEvents = 'none';
                    btn.style.cursor = 'not-allowed';
                }
            });
        }

        // Ripristina ultimo risultato se disponibile
        if (parsedState.roundsCompletati.length > 0) {
            const ultimoRound = parsedState.roundsCompletati[parsedState.roundsCompletati.length - 1];
            const ultimiRisultati = parsedState.astePerRound[ultimoRound];
            
            if (ultimiRisultati && ultimiRisultati.length > 0) {
                updateLastRoundResults(ultimoRound, ultimiRisultati);
            }
        }

        // Aggiorna statistiche
        updateStatsFromSavedData(parsedState);
        
        showNotification('üîÑ Stato del gioco ripristinato!', 'success');
        return true;
        
    } catch (error) {
        console.error('‚ùå Errore caricamento stato Master:', error);
        clearMasterState();
        return false;
    }
}

// NUOVA FUNZIONE: Aggiorna statistiche da dati salvati
function updateStatsFromSavedData(parsedState) {
    try {
        // Aggiorna contatori
        document.getElementById('statRounds').textContent = parsedState.roundsCompletati.length;
        
        // Calcola crediti spesi totali
        let creditiSpesiTotali = 0;
        Object.values(parsedState.astePerRound).forEach(roundResults => {
            roundResults.forEach(risultato => {
                creditiSpesiTotali += risultato.costo_finale || 0;
            });
        });
        document.getElementById('statCrediti').textContent = creditiSpesiTotali;
        
        // Aggiorna partecipanti connessi (verr√† aggiornato quando si riconnettono)
        document.getElementById('statConnessi').textContent = '0';
        document.getElementById('statOfferte').textContent = '0';
        
    } catch (error) {
        console.error('Errore aggiornamento statistiche:', error);
    }
}

// NUOVA FUNZIONE: Aggiorna display ultimo round
function updateLastRoundResults(round, risultati) {
    let html = `<h3>Round ${round} - ${risultati.length} assegnazioni</h3>`;
    html += '<table class="results-table"><thead><tr>';
    html += '<th>Slot</th><th>Vincitore</th><th>Offerta</th><th>Costo</th>';
    html += '</tr></thead><tbody>';

    risultati.forEach(r => {
        html += `<tr>
            <td><strong>${r.slot_id || r.slot}</strong></td>
            <td>${r.partecipante_nome || r.nome}</td>
            <td>${r.offerta || r.offertaOriginale}</td>
            <td>${r.costo_finale}</td>
        </tr>`;
    });

    html += '</tbody></table>';
    document.getElementById('lastRoundResults').innerHTML = html;
}

// NUOVA FUNZIONE: Pulisci stato Master
function clearMasterState() {
    try {
        localStorage.removeItem(MASTER_STORAGE_KEYS.GAME_STATE);
        localStorage.removeItem(MASTER_STORAGE_KEYS.LAST_UPDATE);
        console.log('üóëÔ∏è Stato Master rimosso');
    } catch (error) {
        console.error('Errore rimozione stato Master:', error);
    }
}

        // Inizializzazione
        document.addEventListener('DOMContentLoaded', () => {
            initializeSocket();
            caricaStatoIniziale();
            setupEventListeners();
        });

        // Connessione WebSocket
        function initializeSocket() {
            socket = io();

            socket.on('connect', () => {
                showNotification('Connesso al server', 'success');
                updateServerStatus(true);
                
                // Registra come master
                socket.emit('register', {
                    nome: 'Master Control',
                    tipo: 'master'
                });
            });

            socket.on('disconnect', () => {
                showNotification('Disconnesso dal server', 'error');
                updateServerStatus(false);
            });

            socket.on('registered', (data) => {
                if (data.success) {
                    gameState = { ...gameState, ...data.gameState };
                    updateUI();
                }
            });

            socket.on('round_started', (data) => {
                gameState.roundAttivo = data.round;
                gameState.asteAttive = true;
                updateUI();
                showNotification(`Round ${data.round} avviato!`, 'success');
                startOffersDisplay();
            });

            socket.on('offerte_update', (data) => {
                updateOffersDisplay(data);
                updatePartecipantiWithBids(data);
            });

            // Modifica la funzione che gestisce fine round
socket.on('round_ended', (data) => {
    gameState.asteAttive = false;
    gameState.roundAttivo = null;
    updateUI();
    showNotification(`Round ${data.round} terminato!`, 'success');
    
    // AGGIUNGI QUESTE RIGHE PER BLOCCARE IL PULSANTE:
    const completedBtn = document.querySelector(`[data-round="${data.round}"]`);
    if (completedBtn) {
        completedBtn.classList.remove('active', 'available');
        completedBtn.classList.add('completed');
        completedBtn.disabled = true;
        completedBtn.style.opacity = '0.6';
        completedBtn.style.pointerEvents = 'none';
        completedBtn.style.cursor = 'not-allowed';
        console.log(`üîí Pulsante ${data.round} bloccato`);
    }
    
    stopOffersDisplay();
    mostraRisultatiRound(data.round, data.risultati);
    
    setTimeout(() => {
        caricaSquadreInFormazione();
        saveMasterState();
    }, 1000);
});
            socket.on('connessi_update', (connessi) => {
                gameState.connessi = connessi;
                updatePartecipanti();
                updateStats();
            });
        }

        function updateServerStatus(connected) {
            const statusEl = document.getElementById('serverStatus');
            if (connected) {
                statusEl.className = 'status-card status-active';
                statusEl.innerHTML = '<span class="live-indicator"></span>Server attivo - Connesso';
            } else {
                statusEl.className = 'status-card status-error';
                statusEl.innerHTML = '‚ùå Server disconnesso';
            }
        }

        // Caricamento stato iniziale MODIFICATO
        // Caricamento stato iniziale MODIFICATO
        async function caricaStatoIniziale() {
            try {
                // Prima prova a caricare stato salvato
                const statoRipristinato = await loadMasterState();

                // Poi carica stato corrente dal server
                const response = await fetch('/api/stato');
                const stato = await response.json();
                gameState = { ...gameState, ...stato };
                updateUI();

                // NUOVO: Carica squadre in formazione
                await caricaSquadreInFormazione();

                // Salva stato dopo ogni caricamento
                await saveMasterState();

            } catch (error) {
                console.error('Errore caricamento stato:', error);
                showNotification('Errore caricamento stato', 'error');
            }
        }

        // NUOVA FUNZIONE: Carica e mostra tutte le squadre in formazione
        async function caricaSquadreInFormazione() {
            try {
                const partecipanti = await fetch('/api/partecipanti').then(r => r.json());
                const container = document.getElementById('squadreInFormazione');
                container.innerHTML = '';

                if (partecipanti.length === 0) {
                    container.innerHTML = '<p>Nessun partecipante registrato</p>';
                    return;
                }

                const squadreGrid = document.createElement('div');
                squadreGrid.style.display = 'grid';
                squadreGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
                squadreGrid.style.gap = '20px';

                for (const partecipante of partecipanti) {
                    const squadraCard = await creaCardSquadra(partecipante);
                    squadreGrid.appendChild(squadraCard);
                }

                container.appendChild(squadreGrid);
            } catch (error) {
                console.error('Errore caricamento squadre:', error);
                document.getElementById('squadreInFormazione').innerHTML = '<p>Errore caricamento squadre</p>';
            }
        }

        // NUOVA FUNZIONE: Crea card per una squadra
        async function creaCardSquadra(partecipante) {
            const card = document.createElement('div');
            card.style.cssText = `
        background: rgba(255,255,255,0.08);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255,255,255,0.1);
    `;

            try {
                // Carica i giocatori del partecipante
                const squadra = await fetch(`/api/squadra-partecipante/${partecipante.id}`).then(r => r.json());

                const giocatoriAcquistati = squadra.length;
                const creditiSpesi = squadra.reduce((sum, g) => sum + (g.costo_finale || 0), 0);
                const creditiRimasti = partecipante.crediti;

                card.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #4299e1; margin: 0;">${partecipante.nome}</h3>
                <div style="font-size: 0.9em; opacity: 0.8;">
                    ${giocatoriAcquistati}/10 giocatori
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 15px;">
                ${['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'F1', 'F2', 'F3'].map(pos => {
                    const giocatore = squadra.find(g => g.slot_id.startsWith(pos + '_'));
                    if (giocatore) {
                        const teamColor = getTeamColorForMaster(giocatore.colore);
                        return `
                            <div style="
                                background: ${teamColor}40;
                                border: 2px solid ${teamColor};
                                padding: 8px;
                                border-radius: 6px;
                                text-align: center;
                                font-size: 0.8em;
                            ">
                                <strong>${pos}</strong><br>
                                ${giocatore.giocatore_attuale}<br>
                                <small>${giocatore.colore} - ${giocatore.costo_finale}‚Ç¨</small>
                            </div>
                        `;
                    } else {
                        return `
                            <div style="
                                background: rgba(74,85,104,0.3);
                                border: 1px solid #4a5568;
                                padding: 8px;
                                border-radius: 6px;
                                text-align: center;
                                font-size: 0.8em;
                                opacity: 0.6;
                            ">
                                <strong>${pos}</strong><br>
                                -
                            </div>
                        `;
                    }
                }).join('')}
            </div>
            
            <div style="display: flex; justify-content: space-between; font-size: 0.9em; opacity: 0.9;">
                <span>üí∞ Rimasti: ${creditiRimasti}</span>
                <span>üí∏ Spesi: ${creditiSpesi}</span>
                <span>üèÜ Punti: ${squadra.reduce((sum, g) => sum + (g.punti_totali || 0), 0)}</span>
            </div>
        `;
            } catch (error) {
                card.innerHTML = `
            <h3 style="color: #4299e1; margin: 0 0 10px 0;">${partecipante.nome}</h3>
            <p style="opacity: 0.7;">Squadra non ancora formata</p>
            <div style="font-size: 0.9em; opacity: 0.9;">
                üí∞ Crediti: ${partecipante.crediti}
            </div>
        `;
            }

            return card;
        }

        // NUOVA FUNZIONE: Gestione colori per Master
        function getTeamColorForMaster(nomeColore) {
            const colori = {
                'rosso': '#ef4444', 'blu': '#3b82f6', 'verde': '#10b981',
                'giallo': '#f59e0b', 'viola': '#8b5cf6', 'arancione': '#f97316',
                'rosa': '#ec4899', 'azzurro': '#06b6d4', 'marrone': '#92400e',
                'nero': '#374151', 'bianco': '#f3f4f6', 'grigio': '#6b7280',
                'smeraldo': '#10b981', 'royal': '#1e40af', 'ciano': '#06b6d4',
                'lime': '#84cc16', 'bordeaux': '#7c2d12', 'crema': '#fef3c7',
                'lilla': '#c4b5fd'
            };

            const coloreLowerCase = nomeColore.toLowerCase().trim();
            return colori[coloreLowerCase] || '#4299e1';
        }

        // Setup event listeners
        // Setup event listeners
function setupEventListeners() {
    // Selezione round - SOLO SELEZIONE, non avvio
    document.querySelectorAll('.round-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            // AGGIUNTO: controlla se √® completato
            if (!btn.classList.contains('completed') && 
                !btn.classList.contains('active') && 
                !btn.disabled) {
                selectRound(btn.dataset.round);
            }
        });
    });
}

        // Gestione round
        function selectRound(round) {
            // Rimuovi selezione precedente
            document.querySelectorAll('.round-btn').forEach(btn => {
                btn.style.outline = 'none';
                btn.style.boxShadow = 'none';
            });

            // Seleziona nuovo round
            const btn = document.querySelector(`[data-round="${round}"]`);
            btn.style.outline = '3px solid #ffd700';
            btn.style.boxShadow = '0 0 15px rgba(255, 215, 0, 0.5)';
            
            roundSelezionato = round;
            document.getElementById('selectedRoundDisplay').textContent = round;
            document.getElementById('btnAvviaRound').disabled = false;
        }

        async function avviaRound(round) {
            if (gameState.asteAttive) {
                showNotification('Un round √® gi√† attivo!', 'warning');
                return;
            }

            // Conferma avvio
            if (!confirm(`Avviare il round ${round}?\n\nTutti i partecipanti potranno iniziare a fare le loro offerte.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/avvia-round/${round}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // Il socket.io gestir√† l'aggiornamento UI
                    document.querySelector(`[data-round="${round}"]`).classList.remove('available');
                    document.querySelector(`[data-round="${round}"]`).classList.add('active');
                    document.getElementById('btnAvviaRound').disabled = true;
                    document.getElementById('btnFermaRound').disabled = false;
                    
                    // Reset selezione e tracciamento offerte
                    roundSelezionato = null;
                    participantsBids.clear();
                    document.getElementById('selectedRoundDisplay').textContent = 'Round in corso...';
                } else {
                    const error = await response.json();
                    showNotification('Errore: ' + error.error, 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        function avviaRoundSelezionato() {
            if (roundSelezionato) {
                avviaRound(roundSelezionato);
            }
        }

        async function forzaFineRound() {
            if (!gameState.asteAttive) return;

            if (!confirm('Vuoi terminare il round anche se non tutti hanno fatto offerte?\n\nI partecipanti che non hanno offerto non riceveranno giocatori.')) {
                return;
            }

            try {
                const response = await fetch('/api/forza-fine-round', {
                    method: 'POST'
                });

                if (response.ok) {
                    showNotification('Round terminato forzatamente', 'warning');
                } else {
                    showNotification('Errore durante la terminazione forzata', 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        // Gestione display offerte (sostituisce timer)
        function startOffersDisplay() {
            document.getElementById('currentRoundInfo').style.display = 'block';
            document.getElementById('activeRoundName').textContent = gameState.roundAttivo;
            
            // Reset display
            updateOffersDisplay({
                partecipantiConnessi: gameState.connessi.filter(p => p.tipo === 'partecipante').length,
                offerteRicevute: 0,
                mancano: gameState.connessi.filter(p => p.tipo === 'partecipante').length
            });
        }

        function updateOffersDisplay(data) {
            const displayEl = document.getElementById('offersDisplay');
            const messageEl = document.getElementById('offersStatusMessage');
            
            displayEl.textContent = `${data.offerteRicevute}/${data.partecipantiConnessi}`;
            
            if (data.mancano > 0) {
                displayEl.style.color = '#f59e0b';
                messageEl.textContent = `Mancano ${data.mancano} offerte per proseguire`;
            } else {
                displayEl.style.color = '#10b981';
                messageEl.textContent = '‚úÖ Tutti hanno offerto! Elaborazione automatica in corso...';
            }
        }

        function updatePartecipantiWithBids(data) {
            // Aggiorna lo stato delle offerte dei partecipanti
            if (data.dettaglioOfferte) {
                data.dettaglioOfferte.forEach(offerta => {
                    participantsBids.set(offerta.partecipante, offerta.offerta);
                });
            }
            updatePartecipanti();
        }

        function stopOffersDisplay() {
    document.getElementById('currentRoundInfo').style.display = 'none';
    
    // Aggiorna stato round button - MARCA COME COMPLETATO
    if (gameState.roundAttivo) {
        const btn = document.querySelector(`[data-round="${gameState.roundAttivo}"]`);
        if (btn) {
            btn.classList.remove('active', 'available');
            btn.classList.add('completed');
            btn.style.outline = 'none';
            btn.style.boxShadow = 'none';
            btn.disabled = true;  // AGGIUNTO: disabilita fisicamente
            btn.style.opacity = '0.6';
            btn.style.cursor = 'not-allowed';
            btn.style.pointerEvents = 'none';
        }
    }
    
    // Reset selezione e tracciamento
    participantsBids.clear();
    document.getElementById('selectedRoundDisplay').textContent = 'Nessuno';
    document.getElementById('btnAvviaRound').disabled = true;
    document.getElementById('btnFermaRound').disabled = true;
}

        // Update UI
        function updateUI() {
    updateRoundButtons();
    updateControlButtons();
    updatePartecipanti();
    updateStats();
    
    // AGGIUNTO: Mantieni stato completed dopo aggiornamenti
    document.querySelectorAll('.round-btn.completed').forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.pointerEvents = 'none';
        btn.style.cursor = 'not-allowed';
    });
}

        function updateRoundButtons() {
    document.querySelectorAll('.round-btn').forEach(btn => {
        const round = btn.dataset.round;
        
        // AGGIUNTO: Non toccare i pulsanti gi√† completati
        if (btn.classList.contains('completed')) {
            return; // Salta questo pulsante se √® gi√† completato
        }
        
        btn.classList.remove('available', 'active');
        
        if (round === gameState.roundAttivo && gameState.asteAttive) {
            btn.classList.add('active');
        } else {
            btn.classList.add('available');
        }
    });
}

        function updateControlButtons() {
            document.getElementById('btnAvviaRound').disabled = gameState.asteAttive || !roundSelezionato;
            document.getElementById('btnFermaRound').disabled = !gameState.asteAttive;
        }

        function updatePartecipanti() {
            const container = document.getElementById('participantsContainer');
            
            const partecipanti = gameState.connessi.filter(p => p.tipo === 'partecipante');
            
            if (partecipanti.length === 0) {
                container.innerHTML = '<p>Nessun partecipante connesso</p>';
                return;
            }

            container.innerHTML = '';
            const grid = document.createElement('div');
            grid.className = 'participants-grid';

            partecipanti.forEach(p => {
                const card = document.createElement('div');
                card.className = 'participant-card';
                
                // Stato della puntata
                let bidStatus = 'Nessuna offerta';
                let bidClass = 'bid-none';
                
                if (gameState.asteAttive && participantsBids.has(p.nome)) {
                    bidStatus = '‚úÖ Offerta confermata';
                    bidClass = 'bid-confirmed';
                    card.classList.add('bid-confirmed');
                } else if (gameState.asteAttive) {
                    bidStatus = '‚è≥ In attesa...';
                    bidClass = 'bid-pending';
                    card.classList.add('bid-pending');
                }
                
                card.innerHTML = `
                    <div><strong>${p.nome}</strong></div>
                    <div>Stato: ${p.stato}</div>
                    <div class="bid-status ${bidClass}">${bidStatus}</div>
                `;
                
                grid.appendChild(card);
            });

            container.appendChild(grid);
        }

        function updateStats() {
            const connessi = gameState.connessi.filter(p => p.tipo === 'partecipante').length;
            document.getElementById('statConnessi').textContent = connessi;
            
            const offerte = participantsBids.size;
            document.getElementById('statOfferte').textContent = offerte;
            
            // TODO: Aggiornare altre statistiche dal database
            document.getElementById('statRounds').textContent = '0';
            document.getElementById('statCrediti').textContent = '0';
        }

        // Risultati e classifiche
        function mostraRisultatiRound(round, risultati) {
            const modal = document.getElementById('resultsModal');
            const title = document.getElementById('resultsTitle');
            const content = document.getElementById('resultsContent');

            title.textContent = `Risultati Round ${round}`;
            
            let html = '<table class="results-table"><thead><tr>';
            html += '<th>Giocatore</th><th>Vincitore</th><th>Offerta</th><th>Costo Finale</th><th>Condiviso</th>';
            html += '</tr></thead><tbody>';

            risultati.forEach(r => {
                html += `<tr>
                    <td><strong>${r.slot.replace('_', ' ')}</strong></td>
                    <td>${r.nome}</td>
                    <td>${r.offertaOriginale}</td>
                    <td>${r.costoFinale}</td>
                    <td>${r.condiviso ? '‚úÖ' : '‚ùå'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            content.innerHTML = html;
            modal.style.display = 'flex';
            
            // Aggiorna anche la sezione risultati nella pagina
            document.getElementById('lastRoundResults').innerHTML = `
                <h3>Round ${round} - ${risultati.length} assegnazioni</h3>
                ${html}
            `;
        }

        async function mostraClassifica() {
            try {
                const response = await fetch('/api/classifica');
                if (!response.ok) {
                    throw new Error('API non disponibile');
                }
                
                const classifica = await response.json();

                const modal = document.getElementById('classificaModal');
                const content = document.getElementById('classificaContent');

                let html = '<table class="results-table"><thead><tr>';
                html += '<th>Pos</th><th>Nome</th><th>Punti</th><th>Giocatori</th><th>Crediti</th>';
                html += '</tr></thead><tbody>';

                classifica.forEach((p, index) => {
                    html += `<tr>
                        <td><strong>${index + 1}¬∞</strong></td>
                        <td>${p.nome}</td>
                        <td>${p.punti_totali}</td>
                        <td>${p.giocatori_totali}/10</td>
                        <td>${p.crediti}</td>
                    </tr>`;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
                modal.style.display = 'flex';
            } catch (error) {
                showNotification('Classifica non ancora disponibile', 'warning');
            }
        }

        // Strumenti admin
        function vaiASetup() {
            window.location.href = '/setup';
        }

        async function esportaDati() {
            try {
                const response = await fetch('/api/export');
                if (!response.ok) {
                    throw new Error('Export non disponibile');
                }
                
                const data = await response.json();
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fantagts_export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                showNotification('Dati esportati con successo', 'success');
            } catch (error) {
                showNotification('Export non ancora disponibile', 'warning');
            }
        }

        function resetAste() {
            showConfirmModal(
                'Reset Aste',
                'Questa azione canceller√† tutte le aste e ripristiner√† i crediti. Procedere?',
                async () => {
                    try {
                        const response = await fetch('/api/reset/aste', { method: 'POST' });
                        if (response.ok) {
                            showNotification('Aste resettate con successo', 'success');
                            location.reload();
                        } else {
                            showNotification('Errore durante reset', 'error');
                        }
                    } catch (error) {
                        showNotification('Errore di connessione', 'error');
                    }
                }
            );
        }

        function resetTotale() {
            showConfirmModal(
                'Reset Totale',
                'ATTENZIONE: Questa azione canceller√† TUTTI i dati del sistema. √à irreversibile!',
                async () => {
                    try {
                        const response = await fetch('/api/reset/totale', { method: 'POST' });
                        if (response.ok) {
                            showNotification('Sistema resettato completamente', 'success');
                            setTimeout(() => window.location.href = '/setup', 2000);
                        } else {
                            showNotification('Errore durante reset', 'error');
                        }
                    } catch (error) {
                        showNotification('Errore di connessione', 'error');
                    }
                }
            );
        }

        // Utilities
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function showConfirmModal(title, message, onConfirm) {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmBtn').onclick = () => {
                closeModal('confirmModal');
                onConfirm();
            };
            document.getElementById('confirmModal').style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Aggiorna stato ogni 30 secondi
        setInterval(caricaStatoIniziale, 30000);
		
		// Salvataggio automatico ogni 30 secondi quando ci sono cambiamenti
setInterval(async () => {
    if (gameState.asteAttive || document.querySelectorAll('.team-slot.filled').length > 0) {
        await saveMasterState();
    }
}, 30000);

// Salva stato quando si chiude la finestra
window.addEventListener('beforeunload', () => {
    saveMasterState();
});
		
    </script>
</body>
</html>