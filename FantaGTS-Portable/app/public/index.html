<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FantaGTS - Fantasy Tennis</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3Eüéæ%3C/text%3E%3C/svg%3E">

    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            min-height: 100vh;
            color: #e2e8f0;
            padding: 10px;
        }

        .container {
            max-width: 450px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 20px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .registration-form {
            background: rgba(255,255,255,0.08);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .input-group {
            margin-bottom: 20px;
        }

            .input-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: bold;
                color: #cbd5e0;
                font-size: 1.1em;
            }

            .input-group input[type="text"] {
                width: 100%;
                padding: 15px;
                border: none;
                border-radius: 10px;
                background: rgba(255,255,255,0.95);
                color: #2d3748;
                font-size: 1.1em;
                text-align: center;
                border: 1px solid rgba(255,255,255,0.2);
            }

        .checkbox-group {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2);
        }

            .checkbox-group label {
                display: flex;
                align-items: center;
                cursor: pointer;
                font-size: 1em;
                line-height: 1.4;
            }

            .checkbox-group input[type="checkbox"] {
                margin-right: 12px;
                width: 20px;
                height: 20px;
                cursor: pointer;
            }

        .checkbox-description {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 8px;
            color: #cbd5e0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
        }

        .btn-primary {
            background: #4299e1;
            color: white;
            border: 1px solid #4299e1;
        }

            .btn-primary:hover {
                background: #3182ce;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
            }

        .btn:disabled {
            background: #4a5568;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .section {
            background: rgba(255,255,255,0.08);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .user-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .connection-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .status-connected {
            background: rgba(72, 187, 120, 0.2);
            border: 2px solid #48bb78;
            color: #68d391;
        }

        .status-waiting {
            background: rgba(237, 137, 54, 0.2);
            border: 2px solid #ed8936;
            color: #f6ad55;
        }

        .round-info {
            background: rgba(245, 101, 101, 0.2);
            border: 3px solid #f56565;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .big-timer {
            font-size: 3em;
            font-weight: bold;
            color: #4299e1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 15px 0;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .player-card {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

            .player-card:hover {
                transform: translateY(-3px);
                box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                border-color: #4299e1;
            }

            .player-card.selected {
                border-color: #4299e1;
                background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
                color: white;
            }

        .player-name {
            font-weight: bold;
            margin-bottom: 8px;
        }

        .team-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin: 0 auto 8px;
            border: 2px solid white;
        }

        .bid-section {
            background: rgba(255,255,255,0.08);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .selected-player-info {
            background: rgba(72, 187, 120, 0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            border: 2px solid #48bb78;
            color: #68d391;
        }

        .bid-input {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.95);
            color: #2d3748;
            font-size: 1.3em;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .connection-status {
            background: rgba(0,0,0,0.3);
            padding: 6px 12px;
            border-radius: 15px;
            font-weight: 500;
            font-size: 0.85em;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

            .connection-status.connected {
                background: rgba(72, 187, 120, 0.2);
                border: 1px solid rgba(72, 187, 120, 0.4);
            }

            .connection-status.poor {
                background: rgba(236, 201, 75, 0.2);
                border: 1px solid rgba(236, 201, 75, 0.4);
            }

            .connection-status.disconnected {
                background: rgba(245, 101, 101, 0.2);
                border: 1px solid rgba(245, 101, 101, 0.4);
            }

            .connection-status.failed {
                background: rgba(229, 62, 62, 0.3);
                border: 1px solid rgba(229, 62, 62, 0.5);
                animation: pulse 2s infinite;
            }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .confirm-bid {
            width: 100%;
            padding: 15px;
            background: #f56565;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #f56565;
        }

            .confirm-bid:disabled {
                background: #4a5568;
                cursor: not-allowed;
                border-color: #4a5568;
            }

        .my-team {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .team-slots {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        .team-slot {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid transparent;
            min-height: 60px;
        }

            .team-slot.filled {
                background: rgba(72, 187, 120, 0.2);
                border: 4px solid #48bb78;
                color: #68d391;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                min-height: 70px;
            }

                .team-slot.filled small {
                    font-weight: normal;
                    opacity: 0.8;
                }

            .team-slot.empty {
                background: rgba(74, 85, 104, 0.3);
                border-color: #4a5568;
                opacity: 0.7;
                color: #a0aec0;
            }

        @media (max-width: 480px) {
            .players-grid {
                grid-template-columns: 1fr;
            }

            .big-timer {
                font-size: 2.5em;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(66, 153, 225, 0.7);
            }

            100% {
                transform: scale(1.02);
                box-shadow: 0 0 0 10px rgba(66, 153, 225, 0);
            }
        }

        /* Migliora la visibilit√† della sezione asta */
        #bidding-phase {
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

            #bidding-phase.active {
                border-color: #4299e1;
                box-shadow: 0 0 15px rgba(66, 153, 225, 0.3);
            }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéæ FantaGTS</h1>
            <p>Fantasy Tennis del Circolo</p>
        </div>

        <!-- Registrazione -->
        <div id="registration-area">
            <div class="registration-form">
                <h2>üëã Benvenuto!</h2>
                <p style="margin-bottom: 25px;">Inserisci il tuo nome per partecipare al FantaGTS</p>

                <div class="input-group">
                    <label>Il tuo nome:</label>
                    <input type="text" id="playerName" placeholder="Lorenzo Buselli" autocomplete="name">
                </div>

                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="enableNotifications" checked>
                        <span>Desidero ricevere notifiche push</span>
                    </label>
                    <div class="checkbox-description">
                        Riceverai notifiche per aste, risultati e aggiornamenti classifica
                    </div>
                </div>

                <button class="btn btn-primary" onclick="registerPlayer()">
                    üöÄ Entra nel FantaGTS
                </button>
            </div>
        </div>

        <!-- Area di gioco -->
        <div id="game-area" style="display: none;">
            <!-- Stato connessione -->
            <div id="connectionStatus" class="connection-status status-connected">
                ‚úÖ Connesso al FantaGTS
            </div>

            <!-- Info utente -->
            <div class="user-info">
                <div>
                    <strong id="currentPlayer">--</strong>
                </div>
                <div>
                    üí∞ <span id="playerCredits">2000</span> crediti
                </div>
            </div>

            <!-- Pulsante logout -->
            <div style="text-align: center; margin-bottom: 15px;">
                <button onclick="logout()" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #e2e8f0; padding: 8px 15px; border-radius: 6px; font-size: 0.9em; cursor: pointer;">
                    üö™ Cambia Utente
                </button>
            </div>

            <!-- Attesa round -->
            <div id="waiting-phase" class="section" style="display: none;">
                <h2>‚è≥ In Attesa</h2>
                <p>Il Master avvier√† il prossimo round quando tutti sono pronti.</p>
                <p><strong>Prossimo round: <span id="nextRound">M1</span></strong></p>
            </div>

            <!-- Round attivo -->
            <div id="bidding-phase" style="display: none;">
                <div class="round-info">
                    <div style="font-size: 1.5em; font-weight: bold; margin-bottom: 10px;">
                        Round <span id="currentRound">M1</span>
                    </div>
                    <div id="offersStatus" class="big-timer">
                        Waiting...
                    </div>
                    <p id="offersMessage">In attesa che tutti facciano le loro offerte</p>
                </div>

                <!-- Griglia giocatori -->
                <div class="players-grid" id="playersGrid">
                    <!-- I giocatori verranno caricati qui -->
                </div>

                <!-- Sezione puntata -->
                <div id="bidSection" class="bid-section" style="display: none;">
                    <div id="selectedPlayerInfo" class="selected-player-info">
                        <strong>Nessun giocatore selezionato</strong>
                    </div>

                    <!-- Sezione crediti e stato connessione -->
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin-bottom: 10px; text-align: center; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <strong>üí∞ Crediti: <span id="creditsDisplay">2000</span></strong>
                        <span id="connection-status" class="connection-status">üü° Connettendo...</span>
                    </div>

                    <input type="number" class="bid-input" id="bidAmount" placeholder="Inserisci quanto vuoi puntare" min="1">

                    <button class="confirm-bid" id="confirmBidBtn" onclick="confirmBid()" disabled>
                        Conferma Puntata
                    </button>
                </div>
            </div>

            <!-- La mia squadra -->
            <div class="my-team">
                <h2>üèÜ La Mia Squadra</h2>
                <div id="myTeamStats">
                    <p>Giocatori: <span id="teamCount">0</span>/10 | Punti: <span id="teamPoints">0</span></p>
                </div>
                <div class="team-slots" id="teamSlots">
                    <div class="team-slot empty" data-position="M1"><strong>M1</strong><br>-</div>
                    <div class="team-slot empty" data-position="M2"><strong>M2</strong><br>-</div>
                    <div class="team-slot empty" data-position="M3"><strong>M3</strong><br>-</div>
                    <div class="team-slot empty" data-position="M4"><strong>M4</strong><br>-</div>
                    <div class="team-slot empty" data-position="M5"><strong>M5</strong><br>-</div>
                    <div class="team-slot empty" data-position="M6"><strong>M6</strong><br>-</div>
                    <div class="team-slot empty" data-position="M7"><strong>M7</strong><br>-</div>
                    <div class="team-slot empty" data-position="F1"><strong>F1</strong><br>-</div>
                    <div class="team-slot empty" data-position="F2"><strong>F2</strong><br>-</div>
                    <div class="team-slot empty" data-position="F3"><strong>F3</strong><br>-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variabili globali
        let socket;
        let playerData = {
            registered: false,
            name: '',
            id: '',
            credits: 2000,
            notificationsEnabled: false
        };

        // SISTEMA DI CONNESSIONE PERSISTENTE MIGLIORATO
        let connectionManager = {
            socket: null,
            heartbeatInterval: null,
            isRegistered: false,

            // Configurazione ottimizzata per velocit√†
            config: {
                heartbeatFrequency: 3000,    // Heartbeat ogni 3 secondi
                connectionTimeout: 5000,     // Timeout 5 secondi
                maxReconnectAttempts: 3,     // Solo 3 tentativi
                reconnectDelay: 1000         // 1 secondo tra tentativi
            },

            // Stato connessione semplificato
            state: {
                isConnected: false,
                reconnectAttempts: 0
            },

            // Inizializza connessione
            initialize() {
                if (typeof io === 'undefined') {
                    console.log('Socket.io non disponibile');
                    return false;
                }
                this.createSocket();
                return true;
            },

            // Crea socket ottimizzato per velocit√†
            createSocket() {
                console.log('üîå Creando connessione socket veloce...');

                this.socket = io({
                    transports: ['polling', 'websocket'], // Polling primo per velocit√†
                    upgrade: true,
                    timeout: this.config.connectionTimeout,

                    // Parametri per connessione rapida
                    pingTimeout: 8000,
                    pingInterval: 4000,

                    // Riconnessione semplificata
                    reconnection: true,
                    reconnectionAttempts: this.config.maxReconnectAttempts,
                    reconnectionDelay: this.config.reconnectDelay
                });

                this.setupEvents();
            },

            // Eventi socket semplificati
            setupEvents() {
                this.socket.on('connect', () => {
                    console.log('‚úÖ Socket connesso VELOCEMENTE');
                    this.state.isConnected = true;
                    this.state.reconnectAttempts = 0;
                    this.startHeartbeat();

                    // Registra SUBITO se i dati sono disponibili
                    if (playerData.registered && !this.isRegistered) {
                        setTimeout(() => {
                            this.registerPlayer();
                        }, 100); // Registra dopo 100ms
                    }

                    this.updateConnectionStatus('connected');
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('‚ùå Socket disconnesso:', reason);
                    this.state.isConnected = false;
                    this.isRegistered = false;
                    this.stopHeartbeat();
                    this.updateConnectionStatus('disconnected');
                });

                this.socket.on('connect_error', (error) => {
                    console.error('‚ùå Errore connessione:', error.message);
                    this.state.reconnectAttempts++;

                    if (this.state.reconnectAttempts >= this.config.maxReconnectAttempts) {
                        console.log('‚ùå Troppi tentativi falliti');
                        this.showConnectionError();
                    }
                });

                this.socket.on('heartbeat_response', () => {
                    // Heartbeat ricevuto - connessione OK
                });

                // Eventi di gioco
                this.setupGameEvents();
            },

            // Eventi specifici del gioco
            setupGameEvents() {
                this.socket.on('registered', (data) => {
                    if (data.success) {
                        console.log('‚úÖ Registrazione confermata SUBITO');
                        this.isRegistered = true;

                        // Aggiorna stato gioco se presente
                        if (data.gameState) {
                            this.handleGameState(data.gameState);
                        }
                    } else {
                        console.error('‚ùå Registrazione fallita:', data.error);
                        if (data.shouldReload) {
                            alert('Sessione non valida. La pagina verr√† ricaricata.');
                            clearSavedSession();
                            location.reload();
                        }
                    }
                });

                this.socket.on('round_started', (data) => {
                    console.log('üéØ Round started ricevuto:', data);
                    showBiddingPhase(data);
                });

                this.socket.on('round_ended', (data) => {
                    console.log('üèÅ Round terminato:', data);
                    showWaitingPhase();
                    if (data.risultati) {
                        updateMyTeamFromResults(data.round, data.risultati);
                    }
                    loadPlayerTeam();
                });

                this.socket.on('offerte_update', (data) => {
                    updateOffersStatus(data);
                });

                this.socket.on('crediti_aggiornati', (data) => {
                    playerData.credits = data.crediti;
                    updateCreditsDisplay();
                    saveSession();
                });

                this.socket.on('bid_confirmed', (data) => {
                    console.log('‚úÖ Offerta confermata:', data);

                    const button = document.getElementById('confirmBidBtn');
                    if (button) {
                        button.disabled = true;
                        button.textContent = '‚úÖ Offerta Confermata';
                        button.style.background = '#10b981';
                    }
                });

                this.socket.on('bid_error', (data) => {
                    console.error('‚ùå Errore offerta:', data);
                    alert('Errore: ' + data.message);
                });

                this.socket.on('show_notification', (data) => {
                    console.log('üîî Notifica ricevuta:', data);
                    alert(`üîî ${data.title}\n\n${data.body}`);
                });

                this.socket.on('reset_bid_state', (data) => {
                    console.log('üîÑ Reset stato offerte:', data);
                    resetBiddingInterface();
                });

                this.socket.on('player_won_exit_auction', (data) => {
                    console.log('üèÜ Hai vinto:', data);
                    document.getElementById('bidding-phase').style.display = 'none';
                    document.getElementById('waiting-phase').style.display = 'block';
                    resetBiddingInterface();
                    loadPlayerTeam();

                    alert(`üèÜ COMPLIMENTI!\n\nHai vinto: ${data.slotWon}\nper ${data.amount} crediti`);
                });

                this.socket.on('aste_resettate', (data) => {
                    console.log('üîÑ Aste resettate:', data);
                    playerData.credits = data.creditiRipristinati;
                    updateCreditsDisplay();
                    resetTeamUI();
                    alert('üîÑ Le aste sono state resettate dal Master!');
                });
            },

            // Registrazione immediata del giocatore
            registerPlayer() {
                if (!this.socket || !this.socket.connected || this.isRegistered || !playerData.registered) {
                    return;
                }

                console.log('üì° Registrando partecipante SUBITO:', playerData.name);

                this.socket.emit('register', {
                    nome: playerData.name,
                    tipo: 'partecipante',
                    partecipanteId: playerData.id
                });
            },

            // Heartbeat semplificato
            startHeartbeat() {
                this.stopHeartbeat();
                this.heartbeatInterval = setInterval(() => {
                    if (this.socket && this.socket.connected) {
                        this.socket.emit('heartbeat', {
                            type: 'client_ping',
                            clientId: playerData.id
                        });
                    }
                }, this.config.heartbeatFrequency);
            },

            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            },

            // Gestisce stato del gioco
            handleGameState(gameState) {
                if (!gameState) return;

                if (gameState.asteAttive || gameState.biddingActive) {
                    console.log('üéØ Aste attive rilevate');
                    // La logica specifica sar√† gestita da eventi dedicati
                } else {
                    console.log('‚è≥ Nessuna asta attiva');
                    showWaitingPhase();
                }
            },

            // Aggiorna stato connessione UI
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                if (!statusElement) return;

                switch (status) {
                    case 'connected':
                        statusElement.className = 'connection-status status-connected';
                        statusElement.innerHTML = '‚úÖ Connesso al FantaGTS';
                        break;
                    case 'disconnected':
                        statusElement.className = 'connection-status status-waiting';
                        statusElement.innerHTML = 'üî¥ Disconnesso dal server';
                        break;
                    default:
                        statusElement.className = 'connection-status status-waiting';
                        statusElement.innerHTML = 'üü° Connettendo...';
                }
            },

            // Mostra errore connessione
            showConnectionError() {
                const reload = confirm(`üî¥ PROBLEMA DI CONNESSIONE\n\nNon riesco a connettermi al server.\n\nVuoi ricaricare la pagina?`);
                if (reload) {
                    location.reload();
                }
            },

            // Pulisci risorse
            cleanup() {
                this.stopHeartbeat();
                if (this.socket) {
                    this.socket.removeAllListeners();
                    this.socket.disconnect();
                }
            }
        };

        // Sostituisci la funzione initializeSocket esistente
        function initializeSocket() {
            return connectionManager.initialize();
        }

        // Esponi il manager globalmente per debug
        window.connectionManager = connectionManager;
       
        // Chiavi per localStorage
        const STORAGE_KEYS = {
            PLAYER_DATA: 'fantagts_player_data',
            REGISTRATION_TIME: 'fantagts_registration_time'
        };

        // Inizializzazione
        document.addEventListener('DOMContentLoaded', () => {
            console.log('FantaGTS Client caricato');
            checkExistingSession();

            // Inizializza il nuovo sistema di connessione
            if (!connectionManager.initialize()) {
                console.log('Socket.io non disponibile, modalit√† base attiva');
                document.getElementById('connection-status').textContent = '‚ùå Socket.io non disponibile';
            }
        });
               
        // Controlla sessione esistente
        async function checkExistingSession() {
            try {
                const savedData = localStorage.getItem(STORAGE_KEYS.PLAYER_DATA);
                const registrationTime = localStorage.getItem(STORAGE_KEYS.REGISTRATION_TIME);

                if (!savedData || !registrationTime) {
                    console.log('Nessuna sessione salvata trovata');
                    return;
                }

                // Controlla se la sessione non √® troppo vecchia (24 ore)
                const now = new Date().getTime();
                const savedTime = parseInt(registrationTime);
                const maxAge = 24 * 60 * 60 * 1000; // 24 ore in millisecondi

                if (now - savedTime > maxAge) {
                    console.log('Sessione scaduta, rimuovo dati salvati');
                    clearSavedSession();
                    return;
                }

                const parsedData = JSON.parse(savedData);

                // Verifica che il partecipante esista ancora nel database
                const response = await fetch('/api/partecipanti');
                if (!response.ok) {
                    console.log('Errore verifica partecipanti esistenti');
                    return;
                }

                const partecipanti = await response.json();
                const partecipanteEsistente = partecipanti.find(p => p.id === parsedData.id);

                // Trova questa sezione nella funzione checkExistingSession():
                if (partecipanteEsistente) {
                    // Ripristina i dati del giocatore
                    playerData = {
                        registered: true,
                        name: parsedData.name,
                        id: parsedData.id,
                        credits: partecipanteEsistente.crediti,
                        notificationsEnabled: parsedData.notificationsEnabled || false
                    };

                    console.log('‚úÖ Sessione ripristinata per:', playerData.name);

                    // AGGIUNTO: Verifica che sia effettivamente registrato nel DB
                    if (!partecipanteEsistente.id) {
                        console.log('‚ùå Giocatore non ha ID valido nel database');
                        clearSavedSession();
                        return;
                    }

                    // Mostra direttamente l'area di gioco
                    document.getElementById('currentPlayer').textContent = playerData.name;
                    document.getElementById('playerCredits').textContent = playerData.credits;
                    showGameArea();

                    // Registra socket quando √® pronto
                    registerSocketWhenReady();

                    // Carica la squadra del giocatore
                    await loadPlayerTeam();

                    // Log di benvenuto (senza alert)
                    console.log(`üëã Bentornato, ${playerData.name}! Crediti: ${playerData.credits}`);
                } else {
                    console.log('‚ùå Partecipante non pi√π esistente nel database o non registrato correttamente');
                    clearSavedSession();
                }

            } catch (error) {
                console.error('Errore durante il ripristino della sessione:', error);
                clearSavedSession();
            }
        }

        // Registra socket quando √® pronto
        function registerSocketWhenReady() {
            // Il nuovo sistema gestisce automaticamente la registrazione
            // quando la connessione √® stabilita
            if (connectionManager.socket && connectionManager.socket.connected) {
                connectionManager.registerPlayer();
            } else {
                // Aspetta che la connessione sia pronta
                setTimeout(() => {
                    if (connectionManager.socket && connectionManager.socket.connected) {
                        connectionManager.registerPlayer();
                    } else {
                        // Forza registrazione appena possibile
                        const checkConnection = setInterval(() => {
                            if (connectionManager.socket && connectionManager.socket.connected) {
                                connectionManager.registerPlayer();
                                clearInterval(checkConnection);
                            }
                        }, 100); // Controlla ogni 100ms

                        // Timeout dopo 5 secondi
                        setTimeout(() => clearInterval(checkConnection), 5000);
                    }
                }, 100);
            }
        }

        // Salva sessione
        function saveSession() {
            try {
                const dataToSave = {
                    name: playerData.name,
                    id: playerData.id,
                    credits: playerData.credits,
                    notificationsEnabled: playerData.notificationsEnabled
                };

                localStorage.setItem(STORAGE_KEYS.PLAYER_DATA, JSON.stringify(dataToSave));
                localStorage.setItem(STORAGE_KEYS.REGISTRATION_TIME, new Date().getTime().toString());

                console.log('‚úÖ Sessione salvata per:', playerData.name);
            } catch (error) {
                console.error('Errore salvataggio sessione:', error);
            }
        }

        // Pulisci sessione salvata
        function clearSavedSession() {
            try {
                localStorage.removeItem(STORAGE_KEYS.PLAYER_DATA);
                localStorage.removeItem(STORAGE_KEYS.REGISTRATION_TIME);
                console.log('üóëÔ∏è Sessione salvata rimossa');
            } catch (error) {
                console.error('Errore rimozione sessione:', error);
            }
        }

        // Connessione WebSocket - ora gestita dal connectionManager
        function initializeSocket() {
            return connectionManager.initialize();
        }
                
        // Registrazione giocatore con controllo duplicati
        async function registerPlayer() {
            const name = document.getElementById('playerName').value.trim();
            const notificationsEnabled = document.getElementById('enableNotifications').checked;

            if (!name || name.length < 2) {
                alert('Inserisci un nome valido (almeno 2 caratteri)!');
                return;
            }

            try {
                // Controllo e registrazione API
                const checkResponse = await fetch('/api/check-player', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nome: name })
                });

                const checkResult = await checkResponse.json();

                if (checkResult.exists && checkResult.inCurrentSession) {
                    // Login immediato
                    playerData.registered = true;
                    playerData.name = checkResult.player.nome;
                    playerData.id = checkResult.player.id;
                    playerData.credits = checkResult.player.crediti;
                    playerData.notificationsEnabled = notificationsEnabled;

                    saveSession();
                    showGameArea();
                    await loadPlayerTeam();

                    // REGISTRAZIONE SOCKET IMMEDIATA
                    setTimeout(() => {
                        connectionManager.registerPlayer();
                    }, 50);

                    console.log(`‚úÖ Login immediato completato per: ${name}`);

                } else if (checkResult.nameAvailable) {
                    // Registrazione nuova
                    const response = await fetch('/api/partecipanti', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ nome: name, crediti: 2000 })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        playerData.registered = true;
                        playerData.name = result.nome;
                        playerData.id = result.id;
                        playerData.credits = result.crediti;
                        playerData.notificationsEnabled = notificationsEnabled;

                        saveSession();
                        showGameArea();
                        await loadPlayerTeam();

                        // REGISTRAZIONE SOCKET IMMEDIATA
                        setTimeout(() => {
                            connectionManager.registerPlayer();
                        }, 50);

                        console.log(`‚úÖ Registrazione immediata completata per: ${name}`);
                    }
                }
            } catch (error) {
                alert('Errore di connessione al server');
                console.error('Errore registrazione:', error);
            }
        }

        // Setup notifiche push - VERSIONE COMPLETA E MIGLIORATA
        async function setupPushNotifications() {
            try {
                console.log('üîî Inizializzazione notifiche push...');

                // STEP 1: Verifica supporto notifiche
                if (!('Notification' in window)) {
                    console.log('‚ùå Browser non supporta notifiche');
                    return { success: false, reason: 'Browser non supportato' };
                }

                if (!('serviceWorker' in navigator)) {
                    console.log('‚ùå Browser non supporta service worker');
                    return { success: false, reason: 'Service Worker non supportato' };
                }

                // STEP 2: Richiedi permesso notifiche
                console.log('üîê Richiedendo permesso notifiche...');
                const permission = await Notification.requestPermission();

                if (permission !== 'granted') {
                    console.log('‚ùå Permesso notifiche negato');
                    return { success: false, reason: 'Permesso negato' };
                }

                console.log('‚úÖ Permesso notifiche concesso');

                // STEP 3: Attendi che service worker sia pronto (con timeout)
                console.log('‚è≥ Attendendo service worker...');
                try {
                    const registration = await Promise.race([
                        navigator.serviceWorker.ready,
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('Service Worker timeout')), 5000)
                        )
                    ]);
                    console.log('‚úÖ Service worker pronto');
                } catch (error) {
                    console.log('‚ö†Ô∏è Service worker non disponibile, continuo senza notifiche');
                    return { success: false, reason: 'Service Worker timeout' };
                }

                // STEP 4: Ottieni chiave pubblica dal server
                console.log('üîë Ottenendo chiave pubblica dal server...');
                const keyResponse = await fetch('/api/vapid-public-key');

                if (!keyResponse.ok) {
                    console.log('‚ùå Server Web Push non configurato');
                    return { success: false, reason: 'Server non configurato' };
                }

                const keyData = await keyResponse.json();
                const publicKey = keyData.publicKey;

                console.log('üîë Chiave pubblica ricevuta:', publicKey.substring(0, 30) + '...');

                // STEP 5: Rimuovi subscription esistenti
                try {
                    console.log('üóëÔ∏è Controllando subscription esistenti...');
                    const existingSubscription = await registration.pushManager.getSubscription();

                    if (existingSubscription) {
                        console.log('üóëÔ∏è Rimuovendo subscription locale esistente...');
                        await existingSubscription.unsubscribe();
                        console.log('‚úÖ Subscription locale rimossa');
                    } else {
                        console.log('‚ÑπÔ∏è Nessuna subscription locale esistente');
                    }
                } catch (unsubError) {
                    console.log('‚ö†Ô∏è Errore rimozione subscription locale:', unsubError.message);
                    // Continua comunque
                }

                // STEP 6: Crea nuova subscription
                console.log('üÜï Creando nuova subscription push...');
                const subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: urlBase64ToUint8Array(publicKey)
                });

                console.log('‚úÖ Nuova subscription creata con successo');

                // STEP 7: Invia subscription al server
                console.log('üì§ Inviando subscription al server...');
                const subscribeResponse = await fetch('/api/subscribe-notifications', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription: subscription,
                        partecipanteId: playerData.id
                    })
                });

                if (!subscribeResponse.ok) {
                    const error = await subscribeResponse.json();
                    console.error('‚ùå Errore registrazione subscription server:', error);
                    return { success: false, reason: 'Errore server: ' + error.error };
                }

                const result = await subscribeResponse.json();
                console.log('‚úÖ Subscription registrata sul server:', result);

                // STEP 8: Test notifica immediata
                try {
                    console.log('üß™ Inviando notifica di test...');
                    const testNotification = new Notification('FantaGTS', {
                        body: 'Notifiche push attivate con successo! üéæ',
                        icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Ctext y=".9em" font-size="90"%3Eüéæ%3C/text%3E%3C/svg%3E',
                        badge: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Ctext y=".9em" font-size="90"%3Eüéæ%3C/text%3E%3C/svg%3E',
                        vibrate: [100, 50, 100],
                        requireInteraction: false,
                        silent: false
                    });

                    // Chiudi automaticamente la notifica di test dopo 3 secondi
                    setTimeout(() => {
                        try {
                            testNotification.close();
                        } catch (e) {
                            // Ignora errori di chiusura
                        }
                    }, 3000);

                    console.log('‚úÖ Notifica di test inviata');
                } catch (testNotifError) {
                    console.log('‚ö†Ô∏è Impossibile inviare notifica di test:', testNotifError.message);
                    // Non √® un errore critico
                }

                console.log('üéâ Setup notifiche push completato con successo!');
                return {
                    success: true,
                    message: 'Notifiche push configurate correttamente',
                    subscriptionCount: result.saved || 1
                };

            } catch (error) {
                console.error('‚ùå ERRORE CRITICO setup notifiche:', error);

                // Prova a mostrare un alert con l'errore specifico
                try {
                    alert(`‚ùå Errore configurazione notifiche:\n\n${error.message}\n\nLe notifiche non funzioneranno, ma puoi comunque usare l'app.`);
                } catch (alertError) {
                    console.error('Impossibile mostrare alert errore');
                }

                return {
                    success: false,
                    reason: 'Errore critico: ' + error.message,
                    error: error
                };
            }
        }

        // Utility per convertire VAPID key
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');

            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);

            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        function showGameArea() {
            document.getElementById('registration-area').style.display = 'none';
            document.getElementById('game-area').style.display = 'block';
            showWaitingPhase();
        }

        function showWaitingPhase() {
            document.getElementById('waiting-phase').style.display = 'block';
            document.getElementById('bidding-phase').style.display = 'none';
        }

        function showBiddingPhase(data) {
            console.log('üéÆ showBiddingPhase chiamata con:', data);

            // NUOVO: Verifica se questo partecipante dovrebbe ancora partecipare
            if (data.partecipantiInAttesa && !data.partecipantiInAttesa.includes(playerData.id)) {
                console.log('‚ö†Ô∏è Questo partecipante ha gi√† vinto - non mostrare asta');
                showWaitingPhase();
                return;
            }

            // FORZA reset di tutte le sezioni
            document.getElementById('waiting-phase').style.display = 'none';
            document.getElementById('bidding-phase').style.display = 'block';

            if (data && data.round) {
                document.getElementById('currentRound').textContent = data.round;

                // NUOVO: Verifica che i slots esistano
                if (data.slots && Array.isArray(data.slots)) {
                    console.log('üìã Caricando giocatori per round:', data.round, 'Slots:', data.slots.length);
                    loadAvailablePlayers(data.slots);
                } else {
                    console.log('‚ö†Ô∏è Nessun slot fornito, caricando dal server...');
                    // Fallback: carica slots dal server
                    loadSlotsForActiveRound(data.round);
                }
            }

            // Scroll automatico - ora pi√π aggressivo
            setTimeout(() => {
                const biddingSection = document.getElementById('bidding-phase');
                if (biddingSection) {
                    // Scroll immediato in cima alla pagina
                    window.scrollTo({
                        top: 0,
                        behavior: 'auto' // Cambiato da 'smooth' a 'auto' per essere istantaneo
                    });

                    console.log('üì± Scroll istantaneo alla sezione asta completato');
                }
            }, 100); // Ridotto delay
        }

        function updateCreditsDisplay() {
            document.getElementById('creditsDisplay').textContent = playerData.credits;
            document.getElementById('playerCredits').textContent = playerData.credits;
        }

        function showBiddingPhase(data) {
            document.getElementById('waiting-phase').style.display = 'none';
            document.getElementById('bidding-phase').style.display = 'block';

            if (data && data.round) {
                document.getElementById('currentRound').textContent = data.round;
                loadAvailablePlayers(data.slots || []);
            }

            // NUOVO: Scroll automatico alla sezione asta
            setTimeout(() => {
                const biddingSection = document.getElementById('bidding-phase');
                if (biddingSection) {
                    biddingSection.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });

                    // Assicurati che sia visibile
                    window.scrollTo({
                        top: biddingSection.offsetTop - 10,
                        behavior: 'smooth'
                    });

                    console.log('üì± Scroll automatico alla sezione asta completato');

                    // AGGIUNTO: Animazione visiva per attirare attenzione
                    biddingSection.style.animation = 'pulse 0.5s ease-in-out 3 alternate';

                    // Rimuovi animazione dopo 3 secondi
                    setTimeout(() => {
                        biddingSection.style.animation = '';
                    }, 3000);
                }
            }, 500);
        }

        function loadAvailablePlayers(slots) {
            console.log('üéØ loadAvailablePlayers chiamata con:', slots);

            const grid = document.getElementById('playersGrid');
            if (!grid) {
                console.error('‚ùå playersGrid non trovato!');
                return;
            }

            // PULISCI completamente la griglia
            grid.innerHTML = '';

            // NUOVO: Verifica che slots sia un array valido e filtri solo quelli disponibili
            let players = [];

            if (slots && Array.isArray(slots) && slots.length > 0) {
                // FILTRA solo i giocatori ancora disponibili (non gi√† acquistati)
                players = slots.filter(slot => {
                    // Verifica che il giocatore non sia gi√† stato acquistato da qualcuno
                    return slot.giocatore_attuale && slot.giocatore_attuale.trim() !== '';
                });

                console.log(`‚úÖ Usando slots filtrati: ${players.length} disponibili su ${slots.length} totali`);
            } else {
                // Fallback con dati di esempio
                console.log('‚ö†Ô∏è Slots non validi, usando fallback');
                players = [
                    { id: 'LOADING_1', giocatore_attuale: 'Caricamento...', colore: 'grigio' },
                    { id: 'LOADING_2', giocatore_attuale: 'Attendere...', colore: 'grigio' }
                ];
            }

            console.log('üìã Creando cards per', players.length, 'giocatori disponibili');

            if (players.length === 0) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: #f59e0b;">Nessun giocatore disponibile</div>';
                return;
            }

            players.forEach((player, index) => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.dataset.playerId = player.id;

                card.innerHTML = `
            <div class="team-color-dot" style="background-color: ${getTeamColor(player.colore)}"></div>
            <div class="player-name">${player.giocatore_attuale || 'N/A'}</div>
            <div style="font-size: 0.8em; opacity: 0.8;">Squadra ${player.colore}</div>
        `;

                // NUOVO: Aggiungi listener solo se non √® un placeholder
                if (!player.id.startsWith('LOADING_')) {
                    card.addEventListener('click', () => selectPlayer(player));
                } else {
                    card.style.opacity = '0.6';
                    card.style.cursor = 'not-allowed';
                }

                grid.appendChild(card);

                // Log per debug
                console.log(`‚ûï Aggiunta card ${index + 1}: ${player.giocatore_attuale} (${player.colore})`);
            });

            console.log('‚úÖ Griglia giocatori aggiornata:', grid.children.length, 'cards create');

            // NUOVO: Forza re-render della griglia
            grid.style.display = 'none';
            setTimeout(() => {
                grid.style.display = 'grid';
            }, 50);
        }

        function selectPlayer(player) {
            console.log('üéØ Giocatore selezionato:', player);

            // NUOVO: Verifica che non sia gi√† stata fatta un'offerta
            const confirmBtn = document.getElementById('confirmBidBtn');
            if (confirmBtn.textContent.includes('‚úÖ') || confirmBtn.textContent.includes('Confermata')) {
                console.log('‚ùå Offerta gi√† confermata, selezione bloccata');
                return;
            }

            // Reset selezione precedente
            document.querySelectorAll('.player-card').forEach(card => {
                card.classList.remove('selected');
                card.style.border = '';
                card.style.backgroundColor = '';
            });

            // Seleziona nuovo giocatore
            const selectedCard = document.querySelector(`[data-player-id="${player.id}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
                selectedCard.style.border = '3px solid #4299e1';
                selectedCard.style.backgroundColor = 'rgba(66, 153, 225, 0.2)';
            }

            // Mostra sezione puntata
            document.getElementById('bidSection').style.display = 'block';
            document.getElementById('selectedPlayerInfo').innerHTML = `
        <strong>Selezionato: ${player.giocatore_attuale || player.name}</strong><br>
        <small>Squadra ${player.colore}</small>
    `;

            // Reset campo importo e pulsante
            document.getElementById('bidAmount').value = '';
            document.getElementById('confirmBidBtn').disabled = true;
            document.getElementById('confirmBidBtn').textContent = 'Conferma Puntata';
            document.getElementById('confirmBidBtn').style.background = '#f56565';

            updateCreditsDisplay();
            updateBidButton();

            console.log('‚úÖ Selezione giocatore completata');
        }

        function updateBidButton() {
            const button = document.getElementById('confirmBidBtn');
            const amount = parseInt(document.getElementById('bidAmount').value) || 0;
            const hasValidBid = amount > 0 && amount <= playerData.credits;
            const hasSelection = document.querySelector('.player-card.selected') !== null;

            button.disabled = !(hasSelection && hasValidBid);

            if (hasSelection && hasValidBid) {
                const playerName = document.querySelector('.player-card.selected .player-name').textContent;
                button.textContent = `Punta ${amount} su ${playerName}`;
            } else {
                button.textContent = 'Conferma Puntata';
            }
        }

        function confirmBid() {
            const amount = parseInt(document.getElementById('bidAmount').value);
            const selectedCard = document.querySelector('.player-card.selected');

            if (!selectedCard || !amount || amount <= 0) {
                alert('Seleziona un giocatore e inserisci un importo valido!');
                return;
            }

            const playerId = selectedCard.dataset.playerId;
            const playerName = selectedCard.querySelector('.player-name').textContent;

            const confirmMessage = `Stai per puntare\n\n${amount} crediti\n\nsu ${playerName}`;

            if (!confirm(confirmMessage)) {
                return;
            }

            if (socket && socket.connected) {
                socket.emit('place_bid', {
                    round: document.getElementById('currentRound').textContent,
                    slot: playerId,
                    importo: amount
                });
            }

            const button = document.getElementById('confirmBidBtn');
            button.disabled = true;
            button.textContent = '‚è≥ Invio in corso...';
            button.style.background = '#ed8936';
        }

        function updateOffersStatus(data) {
            const statusEl = document.getElementById('offersStatus');
            const messageEl = document.getElementById('offersMessage');

            if (data.mancano > 0) {
                statusEl.textContent = `${data.offerteRicevute}/${data.partecipantiConnessi}`;
                statusEl.style.color = '#f59e0b';
                messageEl.textContent = `Mancano ${data.mancano} offerte per proseguire`;
            } else {
                statusEl.textContent = '‚úÖ Tutti hanno offerto!';
                statusEl.style.color = '#10b981';
                messageEl.textContent = 'Elaborazione risultati in corso...';
            }
        }

        function resetBiddingInterface() {
            console.log('üîÑ Resettando interfaccia aste...');

            // 1. Reset campo importo
            const bidAmount = document.getElementById('bidAmount');
            if (bidAmount) {
                bidAmount.disabled = false;
                bidAmount.value = '';
                bidAmount.placeholder = 'Inserisci quanto vuoi puntare';
            }

            // 2. Reset cards giocatori
            document.querySelectorAll('.player-card').forEach(card => {
                card.style.pointerEvents = 'auto';
                card.style.opacity = '1';
                card.classList.remove('selected');
                card.style.border = '';
                card.style.backgroundColor = '';
            });

            // 3. Reset pulsante conferma
            const confirmBtn = document.getElementById('confirmBidBtn');
            if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.textContent = 'Conferma Puntata';
                confirmBtn.style.background = '#f56565';
                confirmBtn.style.cursor = 'not-allowed';
            }

            // 4. Reset sezione selezione
            const bidSection = document.getElementById('bidSection');
            if (bidSection) {
                bidSection.style.display = 'none';
            }

            // 5. Reset info giocatore selezionato
            const selectedInfo = document.getElementById('selectedPlayerInfo');
            if (selectedInfo) {
                selectedInfo.innerHTML = '<strong>Nessun giocatore selezionato</strong>';
            }

            // 6. Forza aggiornamento crediti
            updateCreditsDisplay();

            console.log('‚úÖ Interfaccia aste resettata completamente');
        }

        function showResultsPhase(data) {
            alert('Round terminato!');
            showWaitingPhase();
        }

        // Carica slots per round attivo
        async function loadSlotsForActiveRound(round) {
            try {
                console.log(`üéØ Caricando slots per round attivo: ${round}`);

                const response = await fetch(`/api/slots-round/${round}`);
                if (response.ok) {
                    const slots = await response.json();
                    console.log(`‚úÖ Slots caricati per ${round}:`, slots);
                    loadAvailablePlayers(slots);
                } else {
                    console.log(`‚ö†Ô∏è Impossibile caricare slots per ${round}`);
                    // Carica slots di default
                    loadAvailablePlayers([]);
                }
            } catch (error) {
                console.error('‚ùå Errore caricamento slots round attivo:', error);
                loadAvailablePlayers([]);
            }
        }

        async function loadPlayerTeam() {
            try {
                console.log('üîÑ Caricando squadra per:', playerData.name);

                const response = await fetch(`/api/squadra-partecipante/${playerData.id}`);
                if (!response.ok) {
                    console.log('Squadra non ancora formata o endpoint non disponibile');
                    resetTeamUI();
                    return;
                }

                const data = await response.json();
                const squadra = data.squadra || data; // Compatibilit√† con vecchia API

                // Aggiorna crediti se disponibili
                if (data.crediti) {
                    playerData.credits = data.crediti;
                    updateCreditsDisplay();
                }
                console.log('‚úÖ Squadra caricata:', squadra);

                // Reset della UI prima di popolare
                resetTeamUI();

                // Popola la squadra
                squadra.forEach(giocatore => {
                    const [posizione] = giocatore.slot_id.split('_');
                    const slotElement = document.querySelector(`[data-position="${posizione}"]`);

                    if (slotElement) {
                        slotElement.classList.remove('empty');
                        slotElement.classList.add('filled');

                        const teamColor = getTeamColor(giocatore.colore);
                        const textColor = getTextColorForTeam(giocatore.colore);

                        slotElement.innerHTML = `
                    <strong style="color: ${textColor} !important;">${posizione}</strong><br>
                    <span style="color: ${textColor} !important;">${giocatore.giocatore_attuale}</span><br>
                    <small style="opacity: 0.8; color: ${textColor} !important;">Squadra: ${giocatore.colore}</small>
                `;

                        slotElement.style.borderColor = teamColor;
                        slotElement.style.borderWidth = '4px';
                        slotElement.style.borderStyle = 'solid';

                        if (teamColor.startsWith('#')) {
                            slotElement.style.backgroundColor = teamColor + '80';
                        } else {
                            slotElement.style.backgroundColor = teamColor.replace('hsl', 'hsla').replace(')', ', 0.5)');
                        }
                    }
                });

                // Aggiorna contatori
                const slotsRiempiti = document.querySelectorAll('.team-slot.filled').length;
                document.getElementById('teamCount').textContent = slotsRiempiti;

                // Calcola punti totali se disponibili
                const puntiTotali = squadra.reduce((sum, g) => sum + (g.punti_totali || 0), 0);
                document.getElementById('teamPoints').textContent = puntiTotali;

                console.log(`‚úÖ Squadra visualizzata: ${slotsRiempiti} giocatori, ${puntiTotali} punti`);

            } catch (error) {
                console.error('‚ùå Errore caricamento squadra:', error);
                resetTeamUI();
            }
        }

        function resetTeamUI() {
            document.querySelectorAll('.team-slot').forEach(slot => {
                slot.classList.remove('filled');
                slot.classList.add('empty');
                slot.style.borderColor = '#4a5568';
                slot.style.backgroundColor = 'rgba(74, 85, 104, 0.3)';

                const position = slot.dataset.position;
                slot.innerHTML = `<strong>${position}</strong><br>-`;
            });

            document.getElementById('teamCount').textContent = '0';
            document.getElementById('teamPoints').textContent = '0';
        }

        function updateMyTeamFromResults(round, risultati) {
            console.log('üîÑ Aggiornando squadra da risultati:', { round, risultati, playerName: playerData.name });

            // CORREZIONE: Verifica che risultati esista ed √® un array
            if (!risultati || !Array.isArray(risultati)) {
                console.log('‚ö†Ô∏è Risultati non validi:', risultati);
                return;
            }

            // NUOVO: Cerca anche per ID partecipante oltre che per nome
            const mieiAcquisti = risultati.filter(r => {
                return r.nome === playerData.name ||
                    r.partecipante === playerData.id ||
                    r.partecipante_nome === playerData.name;
            });

            console.log('üéØ I miei acquisti trovati:', mieiAcquisti);

            if (mieiAcquisti.length === 0) {
                console.log('‚ùå Nessun acquisto trovato per questo giocatore');
                return;
            }

            mieiAcquisti.forEach(acquisto => {
                console.log('üíé Processando acquisto:', acquisto);

                const slotId = acquisto.slot || acquisto.slot_id;
                const [posizione, coloreSquadra] = slotId.split('_');
                const slotElement = document.querySelector(`[data-position="${posizione}"]`);

                if (slotElement) {
                    console.log(`‚úÖ Aggiornando slot ${posizione} con ${slotId}`);

                    slotElement.classList.remove('empty');
                    slotElement.classList.add('filled');

                    // NUOVO: Aggiorna subito con i dati disponibili
                    const teamColor = getTeamColor(coloreSquadra.toLowerCase());
                    const textColor = getTextColorForTeam(coloreSquadra.toLowerCase());

                    // Se abbiamo il nome del giocatore direttamente dai risultati
                    if (acquisto.giocatore_attuale || acquisto.nomeGiocatore) {
                        const nomeGiocatore = acquisto.giocatore_attuale || acquisto.nomeGiocatore;
                        const costoFinale = acquisto.costo_finale || acquisto.costoFinale || 0;

                        slotElement.innerHTML = `
                    <strong style="color: ${textColor} !important;">${posizione}</strong><br>
                    <span style="color: ${textColor} !important;">${nomeGiocatore}</span><br>
                    <small style="opacity: 0.8; color: ${textColor} !important;">Squadra: ${coloreSquadra.toLowerCase()} - ${costoFinale}‚Ç¨</small>
                `;

                        slotElement.style.borderColor = teamColor;
                        slotElement.style.borderWidth = '4px';
                        slotElement.style.borderStyle = 'solid';

                        if (teamColor.startsWith('#')) {
                            slotElement.style.backgroundColor = teamColor + '80';
                        } else {
                            slotElement.style.backgroundColor = teamColor.replace('hsl', 'hsla').replace(')', ', 0.5)');
                        }

                        console.log(`‚úÖ Slot ${posizione} aggiornato immediatamente`);
                    } else {
                        // Fallback: carica info dal server
                        fetch(`/api/slot-info/${slotId}`)
                            .then(response => response.json())
                            .then(slotInfo => {
                                const teamColor = getTeamColor(slotInfo.colore);
                                const textColor = getTextColorForTeam(slotInfo.colore);

                                slotElement.innerHTML = `
                            <strong style="color: ${textColor} !important;">${posizione}</strong><br>
                            <span style="color: ${textColor} !important;">${slotInfo.giocatore_attuale}</span><br>
                            <small style="opacity: 0.8; color: ${textColor} !important;">Squadra: ${slotInfo.colore} - ${acquisto.costo_finale || 0}‚Ç¨</small>
                        `;

                                slotElement.style.borderColor = teamColor;
                                slotElement.style.borderWidth = '4px';
                                slotElement.style.borderStyle = 'solid';

                                if (teamColor.startsWith('#')) {
                                    slotElement.style.backgroundColor = teamColor + '80';
                                } else {
                                    slotElement.style.backgroundColor = teamColor.replace('hsl', 'hsla').replace(')', ', 0.5)');
                                }

                                console.log(`‚úÖ Slot ${posizione} aggiornato da server`);
                            })
                            .catch((error) => {
                                console.error('‚ùå Errore fetch slot-info:', error);
                                // Aggiornamento base senza dettagli
                                slotElement.innerHTML = `<strong>${posizione}</strong><br>Giocatore<br><small>${acquisto.costo_finale || 0}‚Ç¨</small>`;
                                slotElement.style.borderColor = teamColor;
                                slotElement.style.borderWidth = '4px';
                                slotElement.style.borderStyle = 'solid';
                                slotElement.style.backgroundColor = teamColor + '80';
                            });
                    }
                } else {
                    console.error(`‚ùå Slot element non trovato per posizione: ${posizione}`);
                }
            });

            // NUOVO: Aggiorna contatori
            setTimeout(() => {
                const slotsRiempiti = document.querySelectorAll('.team-slot.filled').length;
                document.getElementById('teamCount').textContent = slotsRiempiti;
                console.log(`üìä Contatori aggiornati: ${slotsRiempiti} giocatori`);
            }, 500);
        }

        function getTeamColor(nomeColore) {
            const colori = {
                'rosso': '#ef4444', 'rossa': '#ef4444',
                'blu': '#3b82f6', 'azzurro': '#06b6d4', 'azzurra': '#06b6d4',
                'verde': '#10b981', 'giallo': '#f59e0b', 'gialla': '#f59e0b',
                'viola': '#8b5cf6', 'arancione': '#f97316', 'rosa': '#ec4899',
                'marrone': '#92400e', 'nero': '#374151', 'nera': '#374151',
                'bianco': '#f3f4f6', 'bianca': '#f3f4f6',
                'grigio': '#6b7280', 'grigia': '#6b7280',
                'lime': '#84cc16', 'indaco': '#6366f1', 'fucsia': '#d946ef',
                'smeraldo': '#10b981', 'royal': '#1e40af', 'ciano': '#06b6d4',
                'bordeaux': '#7c2d12', 'crema': '#fef3c7', 'lilla': '#c4b5fd',
                'celeste': '#06b6d4', 'cielo': '#06b6d4',
                'oro': '#eab308', 'dorato': '#eab308', 'dorata': '#eab308',
                'argento': '#9ca3af', 'beige': '#d6d3d1', 'lavanda': '#c4b5fd'
            };

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            if (colori[coloreLowerCase]) {
                return colori[coloreLowerCase];
            }

            return generaColoreHash(nomeColore);
        }

        function getTextColorForTeam(nomeColore) {
            const coloriChiari = [
                'bianco', 'bianca', 'crema', 'giallo', 'gialla',
                'lime', 'oro', 'dorato', 'dorata', 'argento', 'beige'
            ];

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            const isColoreChiaro = coloriChiari.some(colore =>
                coloreLowerCase.includes(colore) || colore.includes(coloreLowerCase)
            );

            return isColoreChiaro ? '#1a202c' : '#ffffff';
        }

        function generaColoreHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }

            const hue = Math.abs(hash) % 360;
            const saturation = 65 + (Math.abs(hash) % 35);
            const lightness = 45 + (Math.abs(hash) % 20);

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function logout() {
            if (confirm('Sei sicuro di voler uscire?\n\nDovrai reinserire i tuoi dati per rientrare.')) {
                clearSavedSession();
                playerData = {
                    registered: false,
                    name: '',
                    id: '',
                    credits: 2000,
                    notificationsEnabled: false
                };

                if (socket && socket.connected) {
                    socket.disconnect();
                }

                location.reload();
            }
        }

        // Event listeners
        document.getElementById('bidAmount').addEventListener('input', updateBidButton);
        document.getElementById('playerName').focus();

        console.log('‚úÖ FantaGTS Client inizializzato correttamente');
    </script>

</body>
</html>