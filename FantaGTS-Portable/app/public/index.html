<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FantaGTS - Fantasy Tennis</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3Eüéæ%3C/text%3E%3C/svg%3E">

    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            min-height: 100vh;
            color: #e2e8f0;
            padding: 10px;
        }

        .container {
            max-width: 450px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 20px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .registration-form {
            background: rgba(255,255,255,0.08);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .input-group {
            margin-bottom: 20px;
        }

            .input-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: bold;
                color: #cbd5e0;
                font-size: 1.1em;
            }

            .input-group input[type="text"] {
                width: 100%;
                padding: 15px;
                border: none;
                border-radius: 10px;
                background: rgba(255,255,255,0.95);
                color: #2d3748;
                font-size: 1.1em;
                text-align: center;
                border: 1px solid rgba(255,255,255,0.2);
            }

        .checkbox-group {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2);
        }

            .checkbox-group label {
                display: flex;
                align-items: center;
                cursor: pointer;
                font-size: 1em;
                line-height: 1.4;
            }

            .checkbox-group input[type="checkbox"] {
                margin-right: 12px;
                width: 20px;
                height: 20px;
                cursor: pointer;
            }

        .checkbox-description {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 8px;
            color: #cbd5e0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
        }

        .btn-primary {
            background: #4299e1;
            color: white;
            border: 1px solid #4299e1;
        }

            .btn-primary:hover {
                background: #3182ce;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
            }

        .btn:disabled {
            background: #4a5568;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .section {
            background: rgba(255,255,255,0.08);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .user-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .connection-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .status-connected {
            background: rgba(72, 187, 120, 0.2);
            border: 2px solid #48bb78;
            color: #68d391;
        }

        .status-waiting {
            background: rgba(237, 137, 54, 0.2);
            border: 2px solid #ed8936;
            color: #f6ad55;
        }

        .round-info {
            background: rgba(245, 101, 101, 0.2);
            border: 3px solid #f56565;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .big-timer {
            font-size: 3em;
            font-weight: bold;
            color: #4299e1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 15px 0;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .player-card {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

            .player-card:hover {
                transform: translateY(-3px);
                box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                border-color: #4299e1;
            }

            .player-card.selected {
                border-color: #4299e1;
                background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
                color: white;
            }

        .player-name {
            font-weight: bold;
            margin-bottom: 8px;
        }

        .team-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin: 0 auto 8px;
            border: 2px solid white;
        }

        .bid-section {
            background: rgba(255,255,255,0.08);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .selected-player-info {
            background: rgba(72, 187, 120, 0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            border: 2px solid #48bb78;
            color: #68d391;
        }

        .bid-input {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.95);
            color: #2d3748;
            font-size: 1.3em;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .confirm-bid {
            width: 100%;
            padding: 15px;
            background: #f56565;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #f56565;
        }

            .confirm-bid:disabled {
                background: #4a5568;
                cursor: not-allowed;
                border-color: #4a5568;
            }

        .my-team {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .team-slots {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        .team-slot {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid transparent;
            min-height: 60px;
        }

            .team-slot.filled {
                background: rgba(72, 187, 120, 0.2);
                border: 4px solid #48bb78;
                color: #68d391;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                min-height: 70px;
            }

                .team-slot.filled small {
                    font-weight: normal;
                    opacity: 0.8;
                }

            .team-slot.empty {
                background: rgba(74, 85, 104, 0.3);
                border-color: #4a5568;
                opacity: 0.7;
                color: #a0aec0;
            }

        @media (max-width: 480px) {
            .players-grid {
                grid-template-columns: 1fr;
            }

            .big-timer {
                font-size: 2.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéæ FantaGTS</h1>
            <p>Fantasy Tennis del Circolo</p>
        </div>

        <!-- Registrazione -->
        <div id="registration-area">
            <div class="registration-form">
                <h2>üëã Benvenuto!</h2>
                <p style="margin-bottom: 25px;">Inserisci il tuo nome per partecipare al FantaGTS</p>

                <div class="input-group">
                    <label>Il tuo nome:</label>
                    <input type="text" id="playerName" placeholder="Lorenzo Buselli" autocomplete="name">
                </div>

                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="enableNotifications" checked>
                        <span>Desidero ricevere notifiche push</span>
                    </label>
                    <div class="checkbox-description">
                        Riceverai notifiche per aste, risultati e aggiornamenti classifica
                    </div>
                </div>

                <button class="btn btn-primary" onclick="registerPlayer()">
                    üöÄ Entra nel FantaGTS
                </button>
            </div>
        </div>

        <!-- Area di gioco -->
        <div id="game-area" style="display: none;">
            <!-- Stato connessione -->
            <div id="connectionStatus" class="connection-status status-connected">
                ‚úÖ Connesso al FantaGTS
            </div>

            <!-- Info utente -->
            <div class="user-info">
                <div>
                    <strong id="currentPlayer">--</strong>
                </div>
                <div>
                    üí∞ <span id="playerCredits">2000</span> crediti
                </div>
            </div>

            <!-- Pulsante logout -->
            <div style="text-align: center; margin-bottom: 15px;">
                <button onclick="logout()" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #e2e8f0; padding: 8px 15px; border-radius: 6px; font-size: 0.9em; cursor: pointer;">
                    üö™ Cambia Utente
                </button>
            </div>

            <!-- Attesa round -->
            <div id="waiting-phase" class="section" style="display: none;">
                <h2>‚è≥ In Attesa</h2>
                <p>Il Master avvier√† il prossimo round quando tutti sono pronti.</p>
                <p><strong>Prossimo round: <span id="nextRound">M1</span></strong></p>
            </div>

            <!-- Round attivo -->
            <div id="bidding-phase" style="display: none;">
                <div class="round-info">
                    <div style="font-size: 1.5em; font-weight: bold; margin-bottom: 10px;">
                        Round <span id="currentRound">M1</span>
                    </div>
                    <div id="offersStatus" class="big-timer">
                        Waiting...
                    </div>
                    <p id="offersMessage">In attesa che tutti facciano le loro offerte</p>
                </div>

                <!-- Griglia giocatori -->
                <div class="players-grid" id="playersGrid">
                    <!-- I giocatori verranno caricati qui -->
                </div>

                <!-- Sezione puntata -->
                <div id="bidSection" class="bid-section" style="display: none;">
                    <div id="selectedPlayerInfo" class="selected-player-info">
                        <strong>Nessun giocatore selezionato</strong>
                    </div>

                    <!-- Sezione crediti -->
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin-bottom: 10px; text-align: center;">
                        <strong>üí∞ Crediti disponibili: <span id="creditsDisplay">2000</span></strong>
                    </div>

                    <input type="number" class="bid-input" id="bidAmount" placeholder="Inserisci quanto vuoi puntare" min="1">

                    <button class="confirm-bid" id="confirmBidBtn" onclick="confirmBid()" disabled>
                        Conferma Puntata
                    </button>
                </div>
            </div>

            <!-- La mia squadra -->
            <div class="my-team">
                <h2>üèÜ La Mia Squadra</h2>
                <div id="myTeamStats">
                    <p>Giocatori: <span id="teamCount">0</span>/10 | Punti: <span id="teamPoints">0</span></p>
                </div>
                <div class="team-slots" id="teamSlots">
                    <div class="team-slot empty" data-position="M1"><strong>M1</strong><br>-</div>
                    <div class="team-slot empty" data-position="M2"><strong>M2</strong><br>-</div>
                    <div class="team-slot empty" data-position="M3"><strong>M3</strong><br>-</div>
                    <div class="team-slot empty" data-position="M4"><strong>M4</strong><br>-</div>
                    <div class="team-slot empty" data-position="M5"><strong>M5</strong><br>-</div>
                    <div class="team-slot empty" data-position="M6"><strong>M6</strong><br>-</div>
                    <div class="team-slot empty" data-position="M7"><strong>M7</strong><br>-</div>
                    <div class="team-slot empty" data-position="F1"><strong>F1</strong><br>-</div>
                    <div class="team-slot empty" data-position="F2"><strong>F2</strong><br>-</div>
                    <div class="team-slot empty" data-position="F3"><strong>F3</strong><br>-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variabili globali
        let socket;
        let playerData = {
            registered: false,
            name: '',
            id: '',
            credits: 2000,
            notificationsEnabled: false
        };

        // SISTEMA DI PERSISTENZA CONNESSIONE
        let connectionPersistence = {
            heartbeatInterval: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 50,
            isReconnecting: false,
            lastServerResponse: Date.now()
        };

        // Chiavi per localStorage
        const STORAGE_KEYS = {
            PLAYER_DATA: 'fantagts_player_data',
            REGISTRATION_TIME: 'fantagts_registration_time'
        };

        // Inizializzazione
        document.addEventListener('DOMContentLoaded', () => {
            console.log('FantaGTS Client caricato');
            checkExistingSession();
            try {
                initializeSocket();
            } catch (error) {
                console.log('Socket.io non disponibile, modalit√† base attiva');
            }
        });

        // Controlla sessione esistente
        async function checkExistingSession() {
            try {
                const savedData = localStorage.getItem(STORAGE_KEYS.PLAYER_DATA);
                const registrationTime = localStorage.getItem(STORAGE_KEYS.REGISTRATION_TIME);

                if (!savedData || !registrationTime) {
                    console.log('Nessuna sessione salvata trovata');
                    return;
                }

                // Controlla se la sessione non √® troppo vecchia (24 ore)
                const now = new Date().getTime();
                const savedTime = parseInt(registrationTime);
                const maxAge = 24 * 60 * 60 * 1000; // 24 ore in millisecondi

                if (now - savedTime > maxAge) {
                    console.log('Sessione scaduta, rimuovo dati salvati');
                    clearSavedSession();
                    return;
                }

                const parsedData = JSON.parse(savedData);

                // Verifica che il partecipante esista ancora nel database
                const response = await fetch('/api/partecipanti');
                if (!response.ok) {
                    console.log('Errore verifica partecipanti esistenti');
                    return;
                }

                const partecipanti = await response.json();
                const partecipanteEsistente = partecipanti.find(p => p.id === parsedData.id);

                // Trova questa sezione nella funzione checkExistingSession():
                if (partecipanteEsistente) {
                    // Ripristina i dati del giocatore
                    playerData = {
                        registered: true,
                        name: parsedData.name,
                        id: parsedData.id,
                        credits: partecipanteEsistente.crediti,
                        notificationsEnabled: parsedData.notificationsEnabled || false
                    };

                    console.log('‚úÖ Sessione ripristinata per:', playerData.name);

                    // AGGIUNTO: Verifica che sia effettivamente registrato nel DB
                    if (!partecipanteEsistente.id) {
                        console.log('‚ùå Giocatore non ha ID valido nel database');
                        clearSavedSession();
                        return;
                    }

                    // Mostra direttamente l'area di gioco
                    document.getElementById('currentPlayer').textContent = playerData.name;
                    document.getElementById('playerCredits').textContent = playerData.credits;
                    showGameArea();

                    // Registra socket quando √® pronto
                    registerSocketWhenReady();

                    // Carica la squadra del giocatore
                    await loadPlayerTeam();

                    // Mostra notifica di benvenuto
                    setTimeout(() => {
                        alert(`üëã Bentornato, ${playerData.name}!\n\nLa tua sessione √® stata ripristinata.\nCrediti disponibili: ${playerData.credits}`);
                    }, 500);

                } else {
                    console.log('‚ùå Partecipante non pi√π esistente nel database o non registrato correttamente');
                    clearSavedSession();
                }

            } catch (error) {
                console.error('Errore durante il ripristino della sessione:', error);
                clearSavedSession();
            }
        }

        // Registra socket quando √® pronto
        function registerSocketWhenReady() {
            const tryRegister = () => {
                if (socket && socket.connected) {
                    console.log('üîå Registrando socket come partecipante:', playerData.name);
                    socket.emit('register', {
                        nome: playerData.name,
                        tipo: 'partecipante',
                        partecipanteId: playerData.id
                    });
                } else {
                    console.log('üîå Socket non ancora pronto, riprovo...');
                    setTimeout(tryRegister, 500);
                }
            };

            // MODIFICA: Registra solo UNA volta quando socket √® pronto
            if (socket && socket.connected) {
                tryRegister();
            } else {
                if (socket) {
                    socket.off('connect'); // Rimuovi listener precedenti
                    socket.on('connect', () => {
                        console.log('üîó Socket connesso, registrando...');
                        tryRegister();
                    });
                } else {
                    setTimeout(() => {
                        if (socket) {
                            registerSocketWhenReady();
                        }
                    }, 1000);
                }
            }
        }

        // Salva sessione
        function saveSession() {
            try {
                const dataToSave = {
                    name: playerData.name,
                    id: playerData.id,
                    credits: playerData.credits,
                    notificationsEnabled: playerData.notificationsEnabled
                };

                localStorage.setItem(STORAGE_KEYS.PLAYER_DATA, JSON.stringify(dataToSave));
                localStorage.setItem(STORAGE_KEYS.REGISTRATION_TIME, new Date().getTime().toString());

                console.log('‚úÖ Sessione salvata per:', playerData.name);
            } catch (error) {
                console.error('Errore salvataggio sessione:', error);
            }
        }

        // Pulisci sessione salvata
        function clearSavedSession() {
            try {
                localStorage.removeItem(STORAGE_KEYS.PLAYER_DATA);
                localStorage.removeItem(STORAGE_KEYS.REGISTRATION_TIME);
                console.log('üóëÔ∏è Sessione salvata rimossa');
            } catch (error) {
                console.error('Errore rimozione sessione:', error);
            }
        }

        // Connessione WebSocket
        function initializeSocket() {
            if (typeof io === 'undefined') {
                console.log('Socket.io non caricato');
                return;
            }

            socket = io();

            socket.on('connect', () => {
                console.log('Connesso al server via WebSocket');
            });

            socket.on('disconnect', () => {
                console.log('Disconnesso dal server');
            });

            socket.on('registered', (data) => {
                if (data.success) {
                    console.log('‚úÖ Registrazione WebSocket confermata per partecipante');

                    // NUOVO: Controlla se c'√® un'asta in corso
                    if (data.gameState) {
                        console.log('üéÆ Stato gioco ricevuto:', data.gameState);

                        if (data.gameState.asteAttive && data.gameState.roundAttivo) {
                            console.log('üî• ASTA IN CORSO! Mostrando interfaccia aste');

                            // Simula la ricezione di un evento round_started
                            showBiddingPhase({
                                round: data.gameState.roundAttivo,
                                slots: [] // I slots verranno caricati dopo
                            });

                            // Richiedi i slots per il round attivo
                            loadSlotsForActiveRound(data.gameState.roundAttivo);
                        } else {
                            console.log('‚è≥ Nessuna asta attiva, mostra fase di attesa');
                            showWaitingPhase();
                        }
                    }
                } else {
                    console.error('‚ùå Registrazione WebSocket fallita:', data);

                    if (data.shouldReload) {
                        alert('‚ùå Sessione non valida. L\'app verr√† ricaricata per permettere una nuova registrazione.');
                        clearSavedSession();
                        location.reload();
                    } else {
                        alert('‚ùå Errore registrazione: ' + (data.error || 'Errore sconosciuto'));
                    }
                }
            });

            socket.on('round_started', (data) => {
                showBiddingPhase(data);
            });

            socket.on('offerte_update', (data) => {
                updateOffersStatus(data);
            });

            socket.on('crediti_aggiornati', (data) => {
                playerData.credits = data.crediti;
                updateCreditsDisplay();
                saveSession();
                console.log('Crediti aggiornati:', data.crediti);
            });

            socket.on('round_ended', (data) => {
                console.log('üèÅ Round terminato ricevuto:', data);

                // NUOVO: Forza aggiornamento crediti prima di tutto
                if (data.creditiAggiornati) {
                    playerData.credits = data.creditiAggiornati;
                    updateCreditsDisplay();
                }

                showResultsPhase(data);

                // MIGLIORATO: Aggiorna squadra con delay per sicurezza
                setTimeout(async () => {
                    console.log('üîÑ Aggiornando squadra dopo round terminato...');

                    // Prima aggiorna dalla risposta diretta
                    if (data.risultati && Array.isArray(data.risultati)) {
                        updateMyTeamFromResults(data.round, data.risultati);
                    }

                    // Poi ricarica completa dal server per sicurezza
                    await loadPlayerTeam();

                    console.log('‚úÖ Squadra aggiornata dopo round terminato');
                }, 1000);

                resetBiddingInterface();
                saveSession();
                showWaitingPhase();

                // NUOVO: Mostra messaggio di conferma
                setTimeout(() => {
                    alert(`üéâ Round ${data.round} completato!\n\nLa tua squadra √® stata aggiornata.`);
                }, 1500);
            });

            socket.on('bid_confirmed', (data) => {
                console.log('‚úÖ Puntata confermata dal server:', data);

                const button = document.getElementById('confirmBidBtn');
                button.disabled = true;
                button.textContent = '‚úÖ Puntata Confermata';
                button.style.background = '#10b981';

                document.querySelectorAll('.player-card').forEach(card => {
                    card.style.pointerEvents = 'none';
                    card.style.opacity = '0.7';
                });
                document.getElementById('bidAmount').disabled = true;

                setTimeout(() => {
                    alert('‚úÖ Puntata confermata!\n\nOra attendi che tutti completino le loro offerte.');
                }, 500);
            });

            socket.on('bid_error', (data) => {
                console.error('‚ùå Errore puntata:', data);
                alert('‚ùå Errore: ' + data.message);
                resetBiddingInterface();
            });

            socket.on('aste_resettate', (data) => {
                console.log('üîÑ Aste resettate dal server:', data);
                playerData.credits = data.creditiRipristinati;
                updateCreditsDisplay();
                resetTeamUI();
                clearSavedSession();
                saveSession();
                alert('üîÑ Le aste sono state resettate dal Master!\n\nLa tua squadra √® stata azzerata e i crediti ripristinati.');
            });

            socket.on('heartbeat_response', (data) => {
                connectionPersistence.lastServerResponse = Date.now();
            });

            socket.on('show_notification', (data) => {
                console.log('üîî NOTIFICA RICEVUTA:', data);

                // Alert immediato
                alert(`üîî ${data.title}\n\n${data.body}`);

                // Notifica browser se supportata
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification(data.title, {
                        body: data.body,
                        icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Ctext y=".9em" font-size="90"%3Eüéæ%3C/text%3E%3C/svg%3E',
                        vibrate: [100, 50, 100]
                    });
                }
            });
        }

        // Registrazione giocatore con controllo duplicati
        async function registerPlayer() {
            const name = document.getElementById('playerName').value.trim();
            const notificationsEnabled = document.getElementById('enableNotifications').checked;

            if (!name) {
                alert('Inserisci il tuo nome!');
                return;
            }

            if (name.length < 2) {
                alert('Il nome deve essere di almeno 2 caratteri!');
                return;
            }

            try {
                // PRIMO: Controlla se esiste gi√†
                console.log('üîç Verificando disponibilit√† del nome...');
                const checkResponse = await fetch('/api/check-player', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nome: name })
                });

                const checkResult = await checkResponse.json();

                if (checkResult.exists && checkResult.inCurrentSession) {
                    // Giocatore gi√† registrato - effettua login
                    console.log('‚úÖ Login giocatore esistente');

                    playerData.registered = true;
                    playerData.name = checkResult.player.nome;
                    playerData.id = checkResult.player.id;
                    playerData.credits = checkResult.player.crediti;
                    playerData.notificationsEnabled = notificationsEnabled;

                    saveSession();
                    document.getElementById('currentPlayer').textContent = name;
                    document.getElementById('playerCredits').textContent = checkResult.player.crediti;
                    updateCreditsDisplay();
                    showGameArea();
                    await loadPlayerTeam();

                    if (notificationsEnabled) {
                        await setupPushNotifications();
                    }
                    registerSocketWhenReady();

                    alert(`‚úÖ Bentornato, ${name}!\n\nHai ${checkResult.player.crediti} crediti disponibili.`);

                } else if (checkResult.nameOccupied) {
                    // Nome gi√† utilizzato in altra sessione
                    const suggestions = checkResult.suggestions.join(', ');
                    alert(`‚ùå ${checkResult.message}\n\nSuggerimenti:\n${suggestions}`);
                    return;

                } else if (checkResult.nameAvailable) {
                    // Nome disponibile - procedi con registrazione
                    console.log('üÜï Registrando nuovo giocatore...');

                    const response = await fetch('/api/partecipanti', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ nome: name, crediti: 2000 })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        playerData.registered = true;
                        playerData.name = result.nome;
                        playerData.id = result.id;
                        playerData.credits = result.crediti;
                        playerData.notificationsEnabled = notificationsEnabled;

                        saveSession();
                        registerSocketWhenReady();
                        document.getElementById('currentPlayer').textContent = name;
                        document.getElementById('playerCredits').textContent = result.crediti;
                        updateCreditsDisplay();
                        showGameArea();
                        await loadPlayerTeam();

                        if (notificationsEnabled) {
                            await setupPushNotifications();
                        }

                        alert(`‚úÖ Registrato con successo!\n\nBenvenuto nel FantaGTS, ${name}!\nHai ricevuto ${result.crediti} crediti iniziali.`);

                    } else {
                        const error = await response.json();
                        if (error.action === 'name_change_required') {
                            alert(`‚ùå ${error.error}\n\nSuggerimenti: ${error.suggestions?.join(', ') || 'Modifica il nome'}`);
                        } else {
                            alert('‚ùå Errore registrazione: ' + error.error);
                        }
                    }
                }
            } catch (error) {
                alert('‚ùå Errore di connessione al server');
                console.error('Errore registrazione:', error);
            }
        }

        // Setup notifiche push - VERSIONE COMPLETA E MIGLIORATA
        async function setupPushNotifications() {
            try {
                console.log('üîî Inizializzazione notifiche push...');

                // STEP 1: Verifica supporto notifiche
                if (!('Notification' in window)) {
                    console.log('‚ùå Browser non supporta notifiche');
                    return { success: false, reason: 'Browser non supportato' };
                }

                if (!('serviceWorker' in navigator)) {
                    console.log('‚ùå Browser non supporta service worker');
                    return { success: false, reason: 'Service Worker non supportato' };
                }

                // STEP 2: Richiedi permesso notifiche
                console.log('üîê Richiedendo permesso notifiche...');
                const permission = await Notification.requestPermission();

                if (permission !== 'granted') {
                    console.log('‚ùå Permesso notifiche negato');
                    return { success: false, reason: 'Permesso negato' };
                }

                console.log('‚úÖ Permesso notifiche concesso');

                // STEP 3: Attendi che service worker sia pronto
                console.log('‚è≥ Attendendo service worker...');
                const registration = await navigator.serviceWorker.ready;
                console.log('‚úÖ Service worker pronto');

                // STEP 4: Ottieni chiave pubblica dal server
                console.log('üîë Ottenendo chiave pubblica dal server...');
                const keyResponse = await fetch('/api/vapid-public-key');

                if (!keyResponse.ok) {
                    console.log('‚ùå Server Web Push non configurato');
                    return { success: false, reason: 'Server non configurato' };
                }

                const keyData = await keyResponse.json();
                const publicKey = keyData.publicKey;

                console.log('üîë Chiave pubblica ricevuta:', publicKey.substring(0, 30) + '...');

                // STEP 5: Rimuovi subscription esistenti
                try {
                    console.log('üóëÔ∏è Controllando subscription esistenti...');
                    const existingSubscription = await registration.pushManager.getSubscription();

                    if (existingSubscription) {
                        console.log('üóëÔ∏è Rimuovendo subscription locale esistente...');
                        await existingSubscription.unsubscribe();
                        console.log('‚úÖ Subscription locale rimossa');
                    } else {
                        console.log('‚ÑπÔ∏è Nessuna subscription locale esistente');
                    }
                } catch (unsubError) {
                    console.log('‚ö†Ô∏è Errore rimozione subscription locale:', unsubError.message);
                    // Continua comunque
                }

                // STEP 6: Crea nuova subscription
                console.log('üÜï Creando nuova subscription push...');
                const subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: urlBase64ToUint8Array(publicKey)
                });

                console.log('‚úÖ Nuova subscription creata con successo');

                // STEP 7: Invia subscription al server
                console.log('üì§ Inviando subscription al server...');
                const subscribeResponse = await fetch('/api/subscribe-notifications', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription: subscription,
                        partecipanteId: playerData.id
                    })
                });

                if (!subscribeResponse.ok) {
                    const error = await subscribeResponse.json();
                    console.error('‚ùå Errore registrazione subscription server:', error);
                    return { success: false, reason: 'Errore server: ' + error.error };
                }

                const result = await subscribeResponse.json();
                console.log('‚úÖ Subscription registrata sul server:', result);

                // STEP 8: Test notifica immediata
                try {
                    console.log('üß™ Inviando notifica di test...');
                    const testNotification = new Notification('FantaGTS', {
                        body: 'Notifiche push attivate con successo! üéæ',
                        icon: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Ctext y=".9em" font-size="90"%3Eüéæ%3C/text%3E%3C/svg%3E',
                        badge: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Ctext y=".9em" font-size="90"%3Eüéæ%3C/text%3E%3C/svg%3E',
                        vibrate: [100, 50, 100],
                        requireInteraction: false,
                        silent: false
                    });

                    // Chiudi automaticamente la notifica di test dopo 3 secondi
                    setTimeout(() => {
                        try {
                            testNotification.close();
                        } catch (e) {
                            // Ignora errori di chiusura
                        }
                    }, 3000);

                    console.log('‚úÖ Notifica di test inviata');
                } catch (testNotifError) {
                    console.log('‚ö†Ô∏è Impossibile inviare notifica di test:', testNotifError.message);
                    // Non √® un errore critico
                }

                console.log('üéâ Setup notifiche push completato con successo!');
                return {
                    success: true,
                    message: 'Notifiche push configurate correttamente',
                    subscriptionCount: result.saved || 1
                };

            } catch (error) {
                console.error('‚ùå ERRORE CRITICO setup notifiche:', error);

                // Prova a mostrare un alert con l'errore specifico
                try {
                    alert(`‚ùå Errore configurazione notifiche:\n\n${error.message}\n\nLe notifiche non funzioneranno, ma puoi comunque usare l'app.`);
                } catch (alertError) {
                    console.error('Impossibile mostrare alert errore');
                }

                return {
                    success: false,
                    reason: 'Errore critico: ' + error.message,
                    error: error
                };
            }
        }

        // Utility per convertire VAPID key
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');

            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);

            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        function showGameArea() {
            document.getElementById('registration-area').style.display = 'none';
            document.getElementById('game-area').style.display = 'block';
            showWaitingPhase();
        }

        function showWaitingPhase() {
            document.getElementById('waiting-phase').style.display = 'block';
            document.getElementById('bidding-phase').style.display = 'none';
        }

        function showBiddingPhase(data) {
            document.getElementById('waiting-phase').style.display = 'none';
            document.getElementById('bidding-phase').style.display = 'block';

            if (data && data.round) {
                document.getElementById('currentRound').textContent = data.round;
                loadAvailablePlayers(data.slots || []);
            }
        }

        function updateCreditsDisplay() {
            document.getElementById('creditsDisplay').textContent = playerData.credits;
            document.getElementById('playerCredits').textContent = playerData.credits;
        }

        function resetBiddingInterface() {
            document.getElementById('bidAmount').disabled = false;
            document.getElementById('bidAmount').value = '';

            document.querySelectorAll('.player-card').forEach(card => {
                card.style.pointerEvents = 'auto';
                card.style.opacity = '1';
                card.classList.remove('selected');
            });

            const confirmBtn = document.getElementById('confirmBidBtn');
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'Conferma Puntata';
            confirmBtn.style.background = '#ef4444';

            document.getElementById('bidSection').style.display = 'none';
            console.log('üîÑ Interfaccia di puntata resettata');
        }

        function loadAvailablePlayers(slots) {
            const grid = document.getElementById('playersGrid');
            grid.innerHTML = '';

            const players = slots.length > 0 ? slots : [
                { id: 'M1_ROSSO', giocatore_attuale: 'SPANO', colore: 'rosso' },
                { id: 'M1_BLU', giocatore_attuale: 'BIANCHI', colore: 'blu' },
                { id: 'M1_VERDE', giocatore_attuale: 'VERDI', colore: 'verde' }
            ];

            players.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.dataset.playerId = player.id;

                card.innerHTML = `
                        <div class="team-color-dot" style="background-color: ${player.colore}"></div>
                        <div class="player-name">${player.giocatore_attuale}</div>
                        <div style="font-size: 0.8em; opacity: 0.8;">Squadra ${player.colore}</div>
                    `;

                card.addEventListener('click', () => selectPlayer(player));
                grid.appendChild(card);
            });
        }

        function selectPlayer(player) {
            document.querySelectorAll('.player-card').forEach(card => {
                card.classList.remove('selected');
            });

            document.querySelector(`[data-player-id="${player.id}"]`).classList.add('selected');

            document.getElementById('bidSection').style.display = 'block';
            document.getElementById('selectedPlayerInfo').innerHTML = `
                    <strong>Selezionato: ${player.giocatore_attuale || player.name}</strong><br>
                    <small>Squadra ${player.colore}</small>
                `;

            updateCreditsDisplay();
            updateBidButton();
        }

        function updateBidButton() {
            const button = document.getElementById('confirmBidBtn');
            const amount = parseInt(document.getElementById('bidAmount').value) || 0;
            const hasValidBid = amount > 0 && amount <= playerData.credits;
            const hasSelection = document.querySelector('.player-card.selected') !== null;

            button.disabled = !(hasSelection && hasValidBid);

            if (hasSelection && hasValidBid) {
                const playerName = document.querySelector('.player-card.selected .player-name').textContent;
                button.textContent = `Punta ${amount} su ${playerName}`;
            } else {
                button.textContent = 'Conferma Puntata';
            }
        }

        function confirmBid() {
            const amount = parseInt(document.getElementById('bidAmount').value);
            const selectedCard = document.querySelector('.player-card.selected');

            if (!selectedCard || !amount || amount <= 0) {
                alert('Seleziona un giocatore e inserisci un importo valido!');
                return;
            }

            const playerId = selectedCard.dataset.playerId;
            const playerName = selectedCard.querySelector('.player-name').textContent;

            const confirmMessage = `Stai per puntare\n\n${amount} crediti\n\nsu ${playerName}`;

            if (!confirm(confirmMessage)) {
                return;
            }

            if (socket && socket.connected) {
                socket.emit('place_bid', {
                    round: document.getElementById('currentRound').textContent,
                    slot: playerId,
                    importo: amount
                });
            }

            const button = document.getElementById('confirmBidBtn');
            button.disabled = true;
            button.textContent = '‚è≥ Invio in corso...';
            button.style.background = '#ed8936';
        }

        function updateOffersStatus(data) {
            const statusEl = document.getElementById('offersStatus');
            const messageEl = document.getElementById('offersMessage');

            if (data.mancano > 0) {
                statusEl.textContent = `${data.offerteRicevute}/${data.partecipantiConnessi}`;
                statusEl.style.color = '#f59e0b';
                messageEl.textContent = `Mancano ${data.mancano} offerte per proseguire`;
            } else {
                statusEl.textContent = '‚úÖ Tutti hanno offerto!';
                statusEl.style.color = '#10b981';
                messageEl.textContent = 'Elaborazione risultati in corso...';
            }
        }

        function showResultsPhase(data) {
            alert('Round terminato!');
            showWaitingPhase();
        }

        // Carica slots per round attivo
        async function loadSlotsForActiveRound(round) {
            try {
                console.log(`üéØ Caricando slots per round attivo: ${round}`);

                const response = await fetch(`/api/slots-round/${round}`);
                if (response.ok) {
                    const slots = await response.json();
                    console.log(`‚úÖ Slots caricati per ${round}:`, slots);
                    loadAvailablePlayers(slots);
                } else {
                    console.log(`‚ö†Ô∏è Impossibile caricare slots per ${round}`);
                    // Carica slots di default
                    loadAvailablePlayers([]);
                }
            } catch (error) {
                console.error('‚ùå Errore caricamento slots round attivo:', error);
                loadAvailablePlayers([]);
            }
        }

        async function loadPlayerTeam() {
            try {
                console.log('üîÑ Caricando squadra per:', playerData.name);

                const response = await fetch(`/api/squadra-partecipante/${playerData.id}`);
                if (!response.ok) {
                    console.log('Squadra non ancora formata o endpoint non disponibile');
                    resetTeamUI();
                    return;
                }

                const data = await response.json();
                const squadra = data.squadra || data; // Compatibilit√† con vecchia API

                // Aggiorna crediti se disponibili
                if (data.crediti) {
                    playerData.credits = data.crediti;
                    updateCreditsDisplay();
                }
                console.log('‚úÖ Squadra caricata:', squadra);

                // Reset della UI prima di popolare
                resetTeamUI();

                // Popola la squadra
                squadra.forEach(giocatore => {
                    const [posizione] = giocatore.slot_id.split('_');
                    const slotElement = document.querySelector(`[data-position="${posizione}"]`);

                    if (slotElement) {
                        slotElement.classList.remove('empty');
                        slotElement.classList.add('filled');

                        const teamColor = getTeamColor(giocatore.colore);
                        const textColor = getTextColorForTeam(giocatore.colore);

                        slotElement.innerHTML = `
                    <strong style="color: ${textColor} !important;">${posizione}</strong><br>
                    <span style="color: ${textColor} !important;">${giocatore.giocatore_attuale}</span><br>
                    <small style="opacity: 0.8; color: ${textColor} !important;">Squadra: ${giocatore.colore}</small>
                `;

                        slotElement.style.borderColor = teamColor;
                        slotElement.style.borderWidth = '4px';
                        slotElement.style.borderStyle = 'solid';

                        if (teamColor.startsWith('#')) {
                            slotElement.style.backgroundColor = teamColor + '80';
                        } else {
                            slotElement.style.backgroundColor = teamColor.replace('hsl', 'hsla').replace(')', ', 0.5)');
                        }
                    }
                });

                // Aggiorna contatori
                const slotsRiempiti = document.querySelectorAll('.team-slot.filled').length;
                document.getElementById('teamCount').textContent = slotsRiempiti;

                // Calcola punti totali se disponibili
                const puntiTotali = squadra.reduce((sum, g) => sum + (g.punti_totali || 0), 0);
                document.getElementById('teamPoints').textContent = puntiTotali;

                console.log(`‚úÖ Squadra visualizzata: ${slotsRiempiti} giocatori, ${puntiTotali} punti`);

            } catch (error) {
                console.error('‚ùå Errore caricamento squadra:', error);
                resetTeamUI();
            }
        }

        function resetTeamUI() {
            document.querySelectorAll('.team-slot').forEach(slot => {
                slot.classList.remove('filled');
                slot.classList.add('empty');
                slot.style.borderColor = '#4a5568';
                slot.style.backgroundColor = 'rgba(74, 85, 104, 0.3)';

                const position = slot.dataset.position;
                slot.innerHTML = `<strong>${position}</strong><br>-`;
            });

            document.getElementById('teamCount').textContent = '0';
            document.getElementById('teamPoints').textContent = '0';
        }

        function updateMyTeamFromResults(round, risultati) {
            console.log('üîÑ Aggiornando squadra da risultati:', { round, risultati, playerName: playerData.name });

            // CORREZIONE: Verifica che risultati esista ed √® un array
            if (!risultati || !Array.isArray(risultati)) {
                console.log('‚ö†Ô∏è Risultati non validi:', risultati);
                return;
            }

            // NUOVO: Cerca anche per ID partecipante oltre che per nome
            const mieiAcquisti = risultati.filter(r => {
                return r.nome === playerData.name ||
                    r.partecipante === playerData.id ||
                    r.partecipante_nome === playerData.name;
            });

            console.log('üéØ I miei acquisti trovati:', mieiAcquisti);

            if (mieiAcquisti.length === 0) {
                console.log('‚ùå Nessun acquisto trovato per questo giocatore');
                return;
            }

            mieiAcquisti.forEach(acquisto => {
                console.log('üíé Processando acquisto:', acquisto);

                const slotId = acquisto.slot || acquisto.slot_id;
                const [posizione, coloreSquadra] = slotId.split('_');
                const slotElement = document.querySelector(`[data-position="${posizione}"]`);

                if (slotElement) {
                    console.log(`‚úÖ Aggiornando slot ${posizione} con ${slotId}`);

                    slotElement.classList.remove('empty');
                    slotElement.classList.add('filled');

                    // NUOVO: Aggiorna subito con i dati disponibili
                    const teamColor = getTeamColor(coloreSquadra.toLowerCase());
                    const textColor = getTextColorForTeam(coloreSquadra.toLowerCase());

                    // Se abbiamo il nome del giocatore direttamente dai risultati
                    if (acquisto.giocatore_attuale || acquisto.nomeGiocatore) {
                        const nomeGiocatore = acquisto.giocatore_attuale || acquisto.nomeGiocatore;
                        const costoFinale = acquisto.costo_finale || acquisto.costoFinale || 0;

                        slotElement.innerHTML = `
                    <strong style="color: ${textColor} !important;">${posizione}</strong><br>
                    <span style="color: ${textColor} !important;">${nomeGiocatore}</span><br>
                    <small style="opacity: 0.8; color: ${textColor} !important;">Squadra: ${coloreSquadra.toLowerCase()} - ${costoFinale}‚Ç¨</small>
                `;

                        slotElement.style.borderColor = teamColor;
                        slotElement.style.borderWidth = '4px';
                        slotElement.style.borderStyle = 'solid';

                        if (teamColor.startsWith('#')) {
                            slotElement.style.backgroundColor = teamColor + '80';
                        } else {
                            slotElement.style.backgroundColor = teamColor.replace('hsl', 'hsla').replace(')', ', 0.5)');
                        }

                        console.log(`‚úÖ Slot ${posizione} aggiornato immediatamente`);
                    } else {
                        // Fallback: carica info dal server
                        fetch(`/api/slot-info/${slotId}`)
                            .then(response => response.json())
                            .then(slotInfo => {
                                const teamColor = getTeamColor(slotInfo.colore);
                                const textColor = getTextColorForTeam(slotInfo.colore);

                                slotElement.innerHTML = `
                            <strong style="color: ${textColor} !important;">${posizione}</strong><br>
                            <span style="color: ${textColor} !important;">${slotInfo.giocatore_attuale}</span><br>
                            <small style="opacity: 0.8; color: ${textColor} !important;">Squadra: ${slotInfo.colore} - ${acquisto.costo_finale || 0}‚Ç¨</small>
                        `;

                                slotElement.style.borderColor = teamColor;
                                slotElement.style.borderWidth = '4px';
                                slotElement.style.borderStyle = 'solid';

                                if (teamColor.startsWith('#')) {
                                    slotElement.style.backgroundColor = teamColor + '80';
                                } else {
                                    slotElement.style.backgroundColor = teamColor.replace('hsl', 'hsla').replace(')', ', 0.5)');
                                }

                                console.log(`‚úÖ Slot ${posizione} aggiornato da server`);
                            })
                            .catch((error) => {
                                console.error('‚ùå Errore fetch slot-info:', error);
                                // Aggiornamento base senza dettagli
                                slotElement.innerHTML = `<strong>${posizione}</strong><br>Giocatore<br><small>${acquisto.costo_finale || 0}‚Ç¨</small>`;
                                slotElement.style.borderColor = teamColor;
                                slotElement.style.borderWidth = '4px';
                                slotElement.style.borderStyle = 'solid';
                                slotElement.style.backgroundColor = teamColor + '80';
                            });
                    }
                } else {
                    console.error(`‚ùå Slot element non trovato per posizione: ${posizione}`);
                }
            });

            // NUOVO: Aggiorna contatori
            setTimeout(() => {
                const slotsRiempiti = document.querySelectorAll('.team-slot.filled').length;
                document.getElementById('teamCount').textContent = slotsRiempiti;
                console.log(`üìä Contatori aggiornati: ${slotsRiempiti} giocatori`);
            }, 500);
        }

        function getTeamColor(nomeColore) {
            const colori = {
                'rosso': '#ef4444', 'rossa': '#ef4444',
                'blu': '#3b82f6', 'azzurro': '#06b6d4', 'azzurra': '#06b6d4',
                'verde': '#10b981', 'giallo': '#f59e0b', 'gialla': '#f59e0b',
                'viola': '#8b5cf6', 'arancione': '#f97316', 'rosa': '#ec4899',
                'marrone': '#92400e', 'nero': '#374151', 'nera': '#374151',
                'bianco': '#f3f4f6', 'bianca': '#f3f4f6',
                'grigio': '#6b7280', 'grigia': '#6b7280',
                'lime': '#84cc16', 'indaco': '#6366f1', 'fucsia': '#d946ef',
                'smeraldo': '#10b981', 'royal': '#1e40af', 'ciano': '#06b6d4',
                'bordeaux': '#7c2d12', 'crema': '#fef3c7', 'lilla': '#c4b5fd',
                'celeste': '#06b6d4', 'cielo': '#06b6d4',
                'oro': '#eab308', 'dorato': '#eab308', 'dorata': '#eab308',
                'argento': '#9ca3af', 'beige': '#d6d3d1', 'lavanda': '#c4b5fd'
            };

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            if (colori[coloreLowerCase]) {
                return colori[coloreLowerCase];
            }

            return generaColoreHash(nomeColore);
        }

        function getTextColorForTeam(nomeColore) {
            const coloriChiari = [
                'bianco', 'bianca', 'crema', 'giallo', 'gialla',
                'lime', 'oro', 'dorato', 'dorata', 'argento', 'beige'
            ];

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            const isColoreChiaro = coloriChiari.some(colore =>
                coloreLowerCase.includes(colore) || colore.includes(coloreLowerCase)
            );

            return isColoreChiaro ? '#1a202c' : '#ffffff';
        }

        function generaColoreHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }

            const hue = Math.abs(hash) % 360;
            const saturation = 65 + (Math.abs(hash) % 35);
            const lightness = 45 + (Math.abs(hash) % 20);

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function logout() {
            if (confirm('Sei sicuro di voler uscire?\n\nDovrai reinserire i tuoi dati per rientrare.')) {
                clearSavedSession();
                playerData = {
                    registered: false,
                    name: '',
                    id: '',
                    credits: 2000,
                    notificationsEnabled: false
                };

                if (socket && socket.connected) {
                    socket.disconnect();
                }

                location.reload();
            }
        }

        // Event listeners
        document.getElementById('bidAmount').addEventListener('input', updateBidButton);
        document.getElementById('playerName').focus();

        console.log('‚úÖ FantaGTS Client inizializzato correttamente');
    </script>

</body>
</html>