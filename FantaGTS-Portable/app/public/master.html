<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FantaGTS - Master Control</title>

    <!-- PWA Configuration -->
    <meta name="theme-color" content="#4299e1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FantaGTS">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-192x192.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-72x72.png">

    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            min-height: 100vh;
            color: #e2e8f0;
            padding: 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .section {
            background: rgba(255,255,255,0.08);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

            .section h2 {
                margin-bottom: 15px;
                color: #4299e1;
                border-bottom: 2px solid #4299e1;
                padding-bottom: 8px;
                font-size: 1.3em;
            }

        .status-card {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .status-active {
            border-left-color: #48bb78;
            background: rgba(72, 187, 120, 0.1);
        }

        .status-waiting {
            border-left-color: #ed8936;
            background: rgba(237, 137, 54, 0.1);
        }

        .status-error {
            border-left-color: #f56565;
            background: rgba(245, 101, 101, 0.1);
        }

        .big-display {
            font-size: 3em;
            text-align: center;
            font-weight: bold;
            color: #4299e1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 20px 0;
        }

        .rounds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .round-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            border: 1px solid rgba(255,255,255,0.2);
        }

            .round-btn.available {
                background: #48bb78;
                color: white;
                border-color: #48bb78;
            }

            .round-btn.active {
                background: #f56565;
                color: white;
                animation: pulse 2s infinite;
                border-color: #f56565;
            }

            .round-btn.completed {
                background: #4a5568;
                color: #a0aec0;
                cursor: not-allowed;
                border-color: #4a5568;
            }

            .round-btn:hover:not(.completed):not(.active) {
                background: #38a169;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4);
            }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-primary {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }

            .btn-primary:hover {
                background: #3182ce;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
            }

        .btn-danger {
            background: #f56565;
            color: white;
            border-color: #f56565;
        }

            .btn-danger:hover {
                background: #e53e3e;
                box-shadow: 0 4px 12px rgba(245, 101, 101, 0.4);
            }

        .btn-warning {
            background: #ed8936;
            color: white;
            border-color: #ed8936;
        }

            .btn-warning:hover {
                background: #dd6b20;
                box-shadow: 0 4px 12px rgba(237, 137, 54, 0.4);
            }

        .btn:disabled {
            background: #4a5568;
            cursor: not-allowed;
            transform: none;
            border-color: #4a5568;
            color: #a0aec0;
        }

        .participants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .participant-card {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4299e1;
            border: 1px solid rgba(255,255,255,0.1);
        }

            .participant-card.bid-confirmed {
                border-left-color: #48bb78;
                background: rgba(72, 187, 120, 0.15);
            }

            .participant-card.bid-pending {
                border-left-color: #ed8936;
                background: rgba(237, 137, 54, 0.15);
            }

            .participant-card.offline {
                border-left-color: #4a5568;
                opacity: 0.6;
            }

        .current-round-display {
            background: rgba(245, 101, 101, 0.2);
            border: 3px solid #f56565;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
        }

        .live-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #f56565;
            border-radius: 50%;
            animation: blink 1s infinite;
            margin-right: 8px;
        }

        @keyframes blink {
            0%, 50% {
                opacity: 1;
            }

            51%, 100% {
                opacity: 0.3;
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #4299e1;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            color: #cbd5e0;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

            .notification.show {
                transform: translateX(0);
            }

            .notification.success {
                background: #48bb78;
            }

            .notification.error {
                background: #f56565;
            }

            .notification.warning {
                background: #ed8936;
            }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            color: #e2e8f0;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

            .results-table th,
            .results-table td {
                padding: 10px;
                text-align: left;
                border-bottom: 1px solid rgba(255,255,255,0.2);
                font-size: 0.9em;
            }

            .results-table th {
                background: rgba(0,0,0,0.3);
                font-weight: bold;
                color: #4299e1;
            }

        .bid-status {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 4px;
            margin-top: 5px;
        }

        .bid-confirmed {
            background: #48bb78;
            color: white;
        }

        .bid-pending {
            background: #ed8936;
            color: white;
        }

        .bid-none {
            background: #4a5568;
            color: #a0aec0;
        }
        @media (max-width: 1200px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .squadre-grid {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
        }

        .squadra-slot {
            transition: all 0.3s ease;
        }

            .squadra-slot:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }

        .squadra-card-master {
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .squadra-header-master {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }

            .squadra-header-master h4 {
                margin: 0;
                color: #4299e1;
                font-size: 1.1em;
            }

        .squadra-stats {
            display: flex;
            gap: 12px;
            font-size: 0.85em;
            flex-wrap: wrap;
        }

        .stat-punti {
            color: #48bb78;
            font-weight: bold;
        }

        .stat-crediti {
            color: #f6ad55;
            font-weight: bold;
        }

        .stat-giocatori {
            color: #4299e1;
            font-weight: bold;
        }

        .giocatori-grid-master {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .giocatore-slot-master {
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            padding: 6px;
            text-align: center;
            font-size: 0.75em;
            border: 1px solid rgba(255,255,255,0.1);
        }

            .giocatore-slot-master.filled {
                border-width: 2px;
            }

        .pos-label {
            font-weight: bold;
            color: #4299e1;
            font-size: 0.8em;
            margin-bottom: 2px;
        }

        .giocatore-nome {
            color: white;
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 2px;
        }

        .giocatore-punti {
            color: #48bb78;
            font-weight: bold;
            font-size: 0.8em;
        }

        .giocatore-squadra {
            color: #a0aec0;
            font-size: 0.7em;
            text-transform: uppercase;
        }

        .squadra-vuota .squadra-vuota-msg {
            text-align: center;
            padding: 20px;
            opacity: 0.6;
            font-style: italic;
        }
    </style>

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ FantaGTS - Master Control</h1>
            <p>Pannello di controllo per gestire aste e monitorare il torneo</p>
            <div id="serverStatus" class="status-card status-active">
                <span class="live-indicator"></span>
                Server attivo - Connesso
            </div>
        </div>

        <!-- Dashboard Principale -->
        <div class="dashboard-grid">
            <!-- Controllo Aste -->
            <div class="section">
                <h2>üéØ Controllo Aste</h2>

                <div id="currentRoundInfo" class="current-round-display" style="display: none;">
                    <h3>Round Attivo: <span id="activeRoundName">M1</span></h3>
                    <div class="big-display" id="offersDisplay">0/0</div>
                    <p id="offersStatusMessage">In attesa delle offerte dei partecipanti</p>
                </div>

                <div class="rounds-grid">
                    <button class="round-btn available" data-round="M1">M1</button>
                    <button class="round-btn available" data-round="M2">M2</button>
                    <button class="round-btn available" data-round="M3">M3</button>
                    <button class="round-btn available" data-round="M4">M4</button>
                    <button class="round-btn available" data-round="M5">M5</button>
                    <button class="round-btn available" data-round="M6">M6</button>
                    <button class="round-btn available" data-round="M7">M7</button>
                    <button class="round-btn available" data-round="F1">F1</button>
                    <button class="round-btn available" data-round="F2">F2</button>
                    <button class="round-btn available" data-round="F3">F3</button>
                </div>

                <div style="margin-top: 20px;">
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center;">
                        <strong>Round selezionato: <span id="selectedRoundDisplay">Nessuno</span></strong>
                    </div>
                    <button class="btn btn-primary" id="btnAvviaRound" onclick="avviaRoundSelezionato()" disabled>
                        üöÄ Avvia Round Selezionato
                    </button>
                    <button class="btn btn-danger" id="btnFermaRound" onclick="forzaFineRound()" disabled>
                        ‚èπÔ∏è Forza Fine Round
                    </button>
                </div>
            </div>

            <!-- Stato Partecipanti -->
            <div class="section">
                <h2>üë• Partecipanti Connessi</h2>
                <div id="participantsContainer">
                    <p>Nessun partecipante connesso</p>
                </div>
            </div>

            <!-- Statistiche Live -->
            <div class="section">
                <h2>üìä Statistiche Live</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="statConnessi">0</div>
                        <div class="stat-label">Connessi</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="statOfferte">0</div>
                        <div class="stat-label">Offerte</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="statRounds">0</div>
                        <div class="stat-label">Round Completati</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="statCrediti">0</div>
                        <div class="stat-label">Crediti Spesi</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Risultati Ultimo Round -->
        <div class="section">
            <h2>üèÜ Risultati Ultimo Round</h2>
            <div id="lastRoundResults">
                <p>Nessun round completato ancora</p>
            </div>
        </div>

        <!-- Squadre in Formazione -->
        <div class="section">
            <h2>üë• Squadre in Formazione</h2>
            <div id="squadreInFormazione">
                <p>Nessuna squadra ancora formata</p>
            </div>
        </div>

        <!-- Strumenti Admin -->
        <div class="section">
            <h2>üîß Strumenti Amministrazione</h2>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                <button class="btn btn-primary" onclick="vaiASetup()">
                    ‚öôÔ∏è Configurazione
                </button>
                <button class="btn btn-primary" onclick="mostraGestionePartecipanti()">
                    üë• Gestisci Partecipanti
                </button>
                <button class="btn btn-primary" onclick="vaiAGestioneIncontri()">
                    ‚öΩ Gestione Incontri
                </button>
                <button class="btn btn-primary" onclick="esportaDati()">
                    üìä Esporta Dati
                </button>
                <button class="btn btn-primary" onclick="mostraClassifica()">
                    üèÜ Classifica
                </button>
                <button class="btn btn-warning" onclick="resetAste()">
                    üîÑ Reset Aste
                </button>
                <button class="btn btn-warning" onclick="pulisciSubscriptions()">
                    üßπ Pulisci Push Subscriptions
                </button>
                <button class="btn btn-danger" onclick="resetTotale()">
                    ‚ö†Ô∏è Reset Totale
                </button>
            </div>
        </div>

        <!-- Gestione Sessioni -->
        <div class="section">
            <h2>üìÖ Gestione Sessioni</h2>
            <div id="sessionInfo" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                <p><strong>Sessione corrente:</strong> <span id="currentSession">Caricamento...</span></p>
                <p><strong>Data inizio:</strong> <span id="sessionDate">-</span></p>
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                <button class="btn btn-primary" onclick="mostraPulisciTest()">
                    üßπ Pulisci Dati Test
                </button>
                <button class="btn btn-warning" onclick="mostraNuovaSessione()">
                    üìÖ Nuova Sessione Annuale
                </button>
                <button class="btn btn-primary" onclick="mostraBackupList()">
                    üì¶ Visualizza Backup
                </button>
            </div>
        </div>

    </div>

    <!-- Modal Risultati Round -->
    <div id="resultsModal" class="modal">
        <div class="modal-content">
            <h3 id="resultsTitle">Risultati Round</h3>
            <div id="resultsContent"></div>
            <button class="btn btn-primary" onclick="closeModal('resultsModal')" style="margin-top: 20px;">
                Chiudi
            </button>
        </div>
    </div>

    <!-- Modal Classifica -->
    <div id="classificaModal" class="modal">
        <div class="modal-content">
            <h3>üèÜ Classifica Generale</h3>
            <div id="classificaContent"></div>
            <button class="btn btn-primary" onclick="closeModal('classificaModal')" style="margin-top: 20px;">
                Chiudi
            </button>
        </div>
    </div>

    <!-- Modal Conferma -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h3 id="confirmTitle">Conferma Azione</h3>
            <p id="confirmMessage">Sei sicuro di voler procedere?</p>
            <div style="margin-top: 20px; text-align: right;">
                <button class="btn btn-secondary" onclick="closeModal('confirmModal')">Annulla</button>
                <button class="btn btn-primary" id="confirmBtn">Conferma</button>
            </div>
        </div>
    </div>

    <!-- Modal Pulisci Test -->
    <div id="pulisciTestModal" class="modal">
        <div class="modal-content">
            <h3>üßπ Pulisci Dati di Test</h3>
            <p>Seleziona i partecipanti <strong>REALI</strong> da mantenere. Tutti gli altri verranno eliminati:</p>
            <div id="participantsList" style="max-height: 300px; overflow-y: auto; margin: 15px 0;">
                <!-- Lista partecipanti verr√† caricata qui -->
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button class="btn btn-secondary" onclick="closeModal('pulisciTestModal')">Annulla</button>
                <button class="btn btn-danger" onclick="eseguiPuliziaTest()">üßπ Pulisci Test</button>
                <button class="btn btn-warning" onclick="eliminaTuttiPartecipanti()">‚ùå Elimina Tutti</button>
            </div>
        </div>
    </div>

    <!-- Modal Nuova Sessione -->
    <div id="nuovaSessioneModal" class="modal">
        <div class="modal-content">
            <h3>üìÖ Crea Nuova Sessione Annuale</h3>
            <p><strong>ATTENZIONE:</strong> Questa azione creer√† un backup dei dati attuali e inizializzer√† un nuovo FantaGTS pulito.</p>

            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Anno:</label>
                <input type="number" id="nuovoAnno" placeholder="2025" min="2024" max="2030"
                       style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
            </div>

            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Descrizione (opzionale):</label>
                <input type="text" id="nuovaDescrizione" placeholder="FantaGTS 2025 - Torneo Primavera"
                       style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
            </div>

            <div style="margin-top: 20px; text-align: right;">
                <button class="btn btn-secondary" onclick="closeModal('nuovaSessioneModal')">Annulla</button>
                <button class="btn btn-warning" onclick="creaNuovaSessione()">üìÖ Crea Nuova Sessione</button>
            </div>
        </div>
    </div>

    <!-- Modal Lista Backup -->
    <div id="backupListModal" class="modal">
        <div class="modal-content">
            <h3>üì¶ Backup Sessioni Precedenti</h3>
            <div id="backupContent">
                <p>Caricamento backup...</p>
            </div>
            <button class="btn btn-primary" onclick="closeModal('backupListModal')" style="margin-top: 20px;">
                Chiudi
            </button>
        </div>
    </div>

    <!-- Modal Gestione Partecipanti -->
    <div id="gestionePartecipantiModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <h3>üë• Gestione Partecipanti Registrati</h3>
            <div id="partecipantiGestioneContent">
                <p>Caricamento partecipanti...</p>
            </div>

            <div style="margin-top: 20px; text-align: center;">
                <button class="btn btn-primary" onclick="ricaricaPartecipantiGestione()">
                    üîÑ Ricarica Lista
                </button>
                <button class="btn btn-secondary" onclick="closeModal('gestionePartecipantiModal')">
                    Chiudi
                </button>
            </div>
        </div>
    </div>

    <script>
        // Variabili globali
        let socket;
        let gameState = {
            fase: 'waiting',
            roundAttivo: null,
            asteAttive: false,
            connessi: [],
            ultimiRisultati: null
        };
        let roundSelezionato = null;
        let participantsBids = new Map(); // Traccia le offerte dei partecipanti

        // NUOVO: Sistema di persistenza per Master
        const MASTER_STORAGE_KEYS = {
            GAME_STATE: 'fantagts_master_game_state',
            COMPLETED_ROUNDS: 'fantagts_completed_rounds',
            LAST_UPDATE: 'fantagts_last_update'
        };

        // NUOVA FUNZIONE: Salva stato completo del gioco
        async function saveMasterState() {
            try {
                // Raccogli tutti i dati necessari dal server
                const [squadre, partecipanti, risultatiPartite, classifica] = await Promise.all([
                    fetch('/api/squadre').then(r => r.json()).catch(() => []),
                    fetch('/api/partecipanti').then(r => r.json()).catch(() => []),
                    fetch('/api/risultati-partite').then(r => r.json()).catch(() => []),
                    fetch('/api/classifica').then(r => r.json()).catch(() => [])
                ]);

                // Ottieni tutti i risultati delle aste per round
                const rounds = ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'F1', 'F2', 'F3'];
                const astePerRound = {};

                for (const round of rounds) {
                    try {
                        const response = await fetch(`/api/aste-round/${round}`);
                        if (response.ok) {
                            astePerRound[round] = await response.json();
                        }
                    } catch (error) {
                        console.log(`Round ${round} non ancora completato`);
                        astePerRound[round] = [];
                    }
                }

                const masterStateData = {
                    gameState: gameState,
                    squadre: squadre,
                    partecipanti: partecipanti,
                    risultatiPartite: risultatiPartite,
                    classifica: classifica,
                    astePerRound: astePerRound,
                    roundsCompletati: rounds.filter(r => astePerRound[r].length > 0),
                    timestamp: new Date().getTime()
                };

                localStorage.setItem(MASTER_STORAGE_KEYS.GAME_STATE, JSON.stringify(masterStateData));
                localStorage.setItem(MASTER_STORAGE_KEYS.LAST_UPDATE, new Date().getTime().toString());

                console.log('‚úÖ Stato Master salvato:', masterStateData);
            } catch (error) {
                console.error('‚ùå Errore salvataggio stato Master:', error);
            }
        }

        // NUOVA FUNZIONE: Carica stato salvato del Master
        async function loadMasterState() {
            try {
                const savedState = localStorage.getItem(MASTER_STORAGE_KEYS.GAME_STATE);
                const lastUpdate = localStorage.getItem(MASTER_STORAGE_KEYS.LAST_UPDATE);

                if (!savedState || !lastUpdate) {
                    console.log('Nessuno stato Master salvato trovato');
                    return false;
                }

                // Controlla se lo stato non √® troppo vecchio (7 giorni)
                const now = new Date().getTime();
                const savedTime = parseInt(lastUpdate);
                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 giorni

                if (now - savedTime > maxAge) {
                    console.log('Stato Master scaduto, rimuovo dati salvati');
                    clearMasterState();
                    return false;
                }

                const parsedState = JSON.parse(savedState);
                console.log('üìä Stato Master caricato:', parsedState);

                // Ripristina stato del gioco
                gameState = parsedState.gameState || gameState;

                // Ripristina rounds completati
                if (parsedState.roundsCompletati) {
                    parsedState.roundsCompletati.forEach(round => {
                        const btn = document.querySelector(`[data-round="${round}"]`);
                        if (btn) {
                            btn.classList.remove('active', 'available');
                            btn.classList.add('completed');
                            btn.disabled = true;
                            btn.style.opacity = '0.6';
                            btn.style.pointerEvents = 'none';
                            btn.style.cursor = 'not-allowed';
                        }
                    });
                }

                // Ripristina ultimo risultato se disponibile
                if (parsedState.roundsCompletati.length > 0) {
                    const ultimoRound = parsedState.roundsCompletati[parsedState.roundsCompletati.length - 1];
                    const ultimiRisultati = parsedState.astePerRound[ultimoRound];

                    if (ultimiRisultati && ultimiRisultati.length > 0) {
                        updateLastRoundResults(ultimoRound, ultimiRisultati);
                    }
                }

                // Aggiorna statistiche
                updateStatsFromSavedData(parsedState);

                showNotification('üîÑ Stato del gioco ripristinato!', 'success');
                return true;

            } catch (error) {
                console.error('‚ùå Errore caricamento stato Master:', error);
                clearMasterState();
                return false;
            }
        }

        // NUOVA FUNZIONE: Aggiorna statistiche da dati salvati
        function updateStatsFromSavedData(parsedState) {
            try {
                // Aggiorna contatori
                document.getElementById('statRounds').textContent = parsedState.roundsCompletati ? parsedState.roundsCompletati.length : 0;

                // Calcola crediti spesi totali
                let creditiSpesiTotali = 0;

                // CORREZIONE: verifica che astePerRound esista ed √® un oggetto
                if (parsedState.astePerRound && typeof parsedState.astePerRound === 'object') {
                    Object.values(parsedState.astePerRound).forEach(roundResults => {
                        // CORREZIONE: verifica che roundResults sia un array
                        if (Array.isArray(roundResults)) {
                            roundResults.forEach(risultato => {
                                creditiSpesiTotali += risultato.costo_finale || 0;
                            });
                        }
                    });
                }

                document.getElementById('statCrediti').textContent = creditiSpesiTotali;

                // Aggiorna partecipanti connessi (verr√† aggiornato quando si riconnettono)
                document.getElementById('statConnessi').textContent = '0';
                document.getElementById('statOfferte').textContent = '0';

            } catch (error) {
                console.error('Errore aggiornamento statistiche:', error);
                // Imposta valori di default in caso di errore
                document.getElementById('statRounds').textContent = '0';
                document.getElementById('statCrediti').textContent = '0';
                document.getElementById('statConnessi').textContent = '0';
                document.getElementById('statOfferte').textContent = '0';
            }
        }

        // NUOVA FUNZIONE: Aggiorna display ultimo round
        function updateLastRoundResults(round, risultati) {
            let html = `<h3>Round ${round} - ${risultati.length} assegnazioni</h3>`;
            html += '<table class="results-table"><thead><tr>';
            html += '<th>Slot</th><th>Vincitore</th><th>Offerta</th><th>Costo</th>';
            html += '</tr></thead><tbody>';

            risultati.forEach(r => {
                html += `<tr>
                        <td><strong>${r.slot_id || r.slot}</strong></td>
                        <td>${r.partecipante_nome || r.nome}</td>
                        <td>${r.offerta || r.offertaOriginale}</td>
                        <td>${r.costo_finale}</td>
                    </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('lastRoundResults').innerHTML = html;
        }

        // NUOVA FUNZIONE: Pulisci stato Master
        function clearMasterState() {
            try {
                localStorage.removeItem(MASTER_STORAGE_KEYS.GAME_STATE);
                localStorage.removeItem(MASTER_STORAGE_KEYS.LAST_UPDATE);
                console.log('üóëÔ∏è Stato Master rimosso');
            } catch (error) {
                console.error('Errore rimozione stato Master:', error);
            }
        }

        // Inizializzazione
        document.addEventListener('DOMContentLoaded', () => {
            initializeSocket();
            caricaStatoIniziale();
            setupEventListeners();
        });

        // Connessione WebSocket
        function initializeSocket() {
            console.log('üîå Inizializzazione Socket.io...');

            // SOSTITUISCI LA FUNZIONE ESISTENTE CON:
            socket = io({
                timeout: 15000,
                retries: 3,
                transports: ['polling', 'websocket'], // Priorit√† a polling per stabilit√†
                upgrade: true,
                rememberUpgrade: false,

                // Configurazioni per problemi di connessione
                pingTimeout: 20000,
                pingInterval: 10000,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 2000,
                reconnectionDelayMax: 10000
            });

            socket.on('connect', () => {
                console.log('‚úÖ Socket connesso (' + socket.io.engine.transport.name + ')');

                // Pulisci fallback HTTP se attivo
                if (window.httpFallbackInterval) {
                    clearInterval(window.httpFallbackInterval);
                    window.httpFallbackInterval = null;

                    // Rimuovi indicatore
                    const indicator = document.getElementById('httpFallbackIndicator');
                    if (indicator) indicator.remove();

                    console.log('üîÑ Fallback HTTP disattivato, Socket.io ripristinato');
                }

                showNotification('Connesso al server', 'success');
                updateServerStatus(true);

                // Registra come master
                socket.emit('register', {
                    nome: 'Master Control',
                    tipo: 'master'
                });
            });

            socket.on('disconnect', (reason) => {
                console.log('‚ùå Socket disconnesso:', reason);
                showNotification('Disconnesso dal server', 'error');
                updateServerStatus(false);

                // Se errore di trasporto, tenta fallback HTTP
                if (reason === 'transport error' || reason === 'transport close') {
                    console.log('üîÑ Avviando fallback HTTP...');
                    startHTTPFallback();
                }
            });

            socket.on('connect_error', (error) => {
                console.log('‚ùå Errore connessione Socket.io:', error.message);
                showNotification('Errore connessione Socket.io, usando HTTP', 'warning');
                startHTTPFallback();
            });

            socket.on('registered', (data) => {
                if (data.success) {
                    gameState = { ...gameState, ...data.gameState };
                    updateUI();
                }
            });

            socket.on('connessi_update', (connessi) => {
                console.log('üîÑ Aggiornamento connessi ricevuto:', connessi);

                // Aggiorna la visualizzazione dei partecipanti
                const partecipanti = connessi.filter(c => c.tipo === 'partecipante');

                // Aggiorna il contatore se esiste
                const contatore = document.getElementById('partecipantiConnessi');
                if (contatore) {
                    contatore.textContent = partecipanti.length;
                }

                // Aggiorna la lista dettagliata se esiste
                updateConnectedParticipants(partecipanti);

                showNotification(`Partecipante connesso: ${partecipanti[partecipanti.length - 1]?.nome || 'Sconosciuto'}`, 'success');
            });

            socket.on('round_started', (data) => {
                gameState.roundAttivo = data.round;
                gameState.asteAttive = true;
                updateUI();
                showNotification(`Round ${data.round} avviato!`, 'success');
                startOffersDisplay();
            });

            socket.on('offerte_update', (data) => {
                updateOffersDisplay(data);
                updatePartecipantiWithBids(data);
            });

            // Modifica la funzione che gestisce fine round
            socket.on('round_ended', (data) => {
                gameState.asteAttive = false;
                gameState.roundAttivo = null;
                updateUI();
                showNotification(`Round ${data.round} terminato!`, 'success');

                // SOSTITUISCI il blocco const completedBtn = document.querySelector... con questo:
                const completedBtn = document.querySelector(`[data-round="${data.round}"]`);
                if (completedBtn) {
                    // DISABILITAZIONE TOTALE
                    completedBtn.classList.remove('active', 'available');
                    completedBtn.classList.add('completed');
                    completedBtn.disabled = true;
                    completedBtn.style.opacity = '0.3';
                    completedBtn.style.pointerEvents = 'none';
                    completedBtn.style.cursor = 'not-allowed';
                    completedBtn.style.filter = 'grayscale(100%)';
                    completedBtn.style.outline = 'none';
                    completedBtn.style.boxShadow = 'none';

                    // RIMUOVI TUTTI GLI EVENT LISTENERS
                    const newBtn = completedBtn.cloneNode(true);
                    completedBtn.parentNode.replaceChild(newBtn, completedBtn);

                    console.log(`üîí Pulsante ${data.round} TOTALMENTE disabilitato`);
                }

                // NUOVO: Seleziona automaticamente il prossimo round disponibile
                const rounds = ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'F1', 'F2', 'F3'];
                const currentIndex = rounds.indexOf(data.round);
                let nextRoundSelected = false;

                // Cerca il prossimo round disponibile
                for (let i = currentIndex + 1; i < rounds.length; i++) {
                    const nextBtn = document.querySelector(`[data-round="${rounds[i]}"]`);
                    if (nextBtn && !nextBtn.classList.contains('completed')) {
                        selectRound(rounds[i]);
                        nextRoundSelected = true;
                        console.log(`‚úÖ Selezionato automaticamente il prossimo round: ${rounds[i]}`);
                        break;
                    }
                }

                // Se non c'√® un prossimo round, deseleziona tutto
                if (!nextRoundSelected) {
                    roundSelezionato = null;
                    document.getElementById('selectedRoundDisplay').textContent = 'Tutti completati';
                    document.getElementById('btnAvviaRound').disabled = true;

                    // Rimuovi selezione da tutti i pulsanti
                    document.querySelectorAll('.round-btn').forEach(btn => {
                        btn.style.outline = 'none';
                        btn.style.boxShadow = 'none';
                    });

                    console.log('üèÅ Tutti i round completati - nessuna selezione');
                }

                stopOffersDisplay();
                mostraRisultatiRound(data.round, data.risultati);

                setTimeout(() => {
                    caricaSquadreInFormazione();
                    saveMasterState();
                }, 1000);
            });

            socket.on('connessi_update', (connessi) => {
                gameState.connessi = connessi;
                updatePartecipanti();
                updateStats();
            });

            socket.on('master_reset_ui', (data) => {
                console.log('üîÑ Reset UI Master ricevuto:', data);

                // Reset tutti i pulsanti round allo stato ORIGINALE (grigio/neutro)
                document.querySelectorAll('.round-btn').forEach(btn => {
                    btn.classList.remove('active', 'completed', 'available');

                    // Stato originale: grigio neutro
                    btn.style.background = '#4a5568';
                    btn.style.color = '#a0aec0';
                    btn.style.borderColor = '#4a5568';
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                    btn.disabled = false;
                    btn.style.pointerEvents = 'auto';
                    btn.style.outline = 'none';
                    btn.style.boxShadow = 'none';
                });

                // Reset selezione
                roundSelezionato = null;
                document.getElementById('selectedRoundDisplay').textContent = 'Nessuno';
                document.getElementById('btnAvviaRound').disabled = true;
                document.getElementById('btnFermaRound').disabled = true;

                // Reset display round attivo
                document.getElementById('currentRoundInfo').style.display = 'none';

                // Reset risultati ultimo round
                document.getElementById('lastRoundResults').innerHTML = '<p>Nessun round completato ancora</p>';

                // Reset statistiche
                document.getElementById('statRounds').textContent = '0';
                document.getElementById('statCrediti').textContent = '0';
                document.getElementById('statOfferte').textContent = '0';

                // Reset squadre in formazione
                document.getElementById('squadreInFormazione').innerHTML = '<p>Nessuna squadra ancora formata</p>';

                showNotification('üîÑ Interfaccia Master resettata!', 'success');
            });
        }

        function updateServerStatus(isConnected) {
            const statusElement = document.getElementById('serverStatus');
            const statusIcon = document.getElementById('serverStatusIcon');

            if (statusElement && statusIcon) {
                if (isConnected) {
                    statusElement.textContent = 'Online';
                    statusElement.className = 'status online';
                    statusIcon.textContent = 'üü¢';
                } else {
                    // AGGIUNGI QUESTO CONTROLLO:
                    if (window.httpFallbackInterval) {
                        statusElement.textContent = 'HTTP Backup';
                        statusElement.className = 'status warning';
                        statusIcon.textContent = 'üü°';
                    } else {
                        statusElement.textContent = 'Offline';
                        statusElement.className = 'status offline';
                        statusIcon.textContent = 'üî¥';
                    }
                }
            }
        }

        // Trova la sezione con le altre funzioni e aggiungi:
        function vaiAGestioneIncontri() {
            window.location.href = '/gestione-incontri';
        }

        // Caricamento stato iniziale MODIFICATO
        async function caricaStatoIniziale() {
            try {
                // Prima prova a caricare stato salvato
                const statoRipristinato = await loadMasterState();

                // Poi carica stato corrente dal server
                const response = await fetch('/api/stato');
                const stato = await response.json();
                gameState = { ...gameState, ...stato };
                updateUI();

                // NUOVO: Carica squadre del circolo per il setup
                await caricaSquadreCircolo();

                // NUOVO: Carica info sessione
                await caricaInfoSessione();

                // NUOVO: Carica squadre in formazione
                await caricaSquadreInFormazione();

                // Salva stato dopo ogni caricamento
                await saveMasterState();

            } catch (error) {
                console.error('Errore caricamento stato:', error);
                showNotification('Errore caricamento stato', 'error');
            }
        }

        // NUOVA FUNZIONE: Carica squadre del circolo
        async function caricaSquadreCircolo() {
            try {
                const response = await fetch('/api/squadre-complete');
                const squadreCircolo = await response.json();

                console.log('üìä Squadre del circolo caricate:', squadreCircolo);

                // Aggiorna la sezione setup se siamo nella fase iniziale
                if (squadreCircolo.length > 0) {
                    gameState.fase = 'ready'; // Sistema pronto se ci sono squadre
                    console.log('‚úÖ Sistema pronto con', squadreCircolo.length, 'squadre');
                }

            } catch (error) {
                console.error('‚ùå Errore caricamento squadre circolo:', error);
            }
        }

        // Mostra gestione partecipanti
        async function mostraGestionePartecipanti() {
            document.getElementById('gestionePartecipantiModal').style.display = 'flex';
            await caricaPartecipantiPerGestione();
        }

        function startHTTPFallback() {
            console.log('üîÑ Avvio modalit√† HTTP fallback...');

            // Mostra indicatore modalit√† fallback
            showHTTPFallbackIndicator();

            // Avvia polling HTTP ogni 3 secondi
            if (window.httpFallbackInterval) {
                clearInterval(window.httpFallbackInterval);
            }

            window.httpFallbackInterval = setInterval(async () => {
                try {
                    // Aggiorna stato generale
                    const statoResponse = await fetch('/api/stato');
                    if (statoResponse.ok) {
                        const stato = await statoResponse.json();
                        updateGameStateHTTP(stato);
                    }

                    // Aggiorna connessi
                    const connessiResponse = await fetch('/api/connessi');
                    if (connessiResponse.ok) {
                        const connessi = await connessiResponse.json();
                        updateConnectedUsersHTTP(connessi);
                    }

                } catch (error) {
                    console.warn('‚ö†Ô∏è Errore polling HTTP:', error);
                }
            }, 3000);
        }

        // AGGIUNGI QUESTE NUOVE FUNZIONI:
        function updateGameStateHTTP(stato) {
            const oldFase = gameState.fase;

            if (stato.fase) gameState.fase = stato.fase;
            if (stato.roundAttivo !== undefined) gameState.roundAttivo = stato.roundAttivo;
            if (stato.asteAttive !== undefined) gameState.asteAttive = stato.asteAttive;

            if (oldFase !== gameState.fase) {
                console.log(`üîÑ Fase aggiornata via HTTP: ${oldFase} ‚Üí ${gameState.fase}`);
                updateUI();
            }
        }

        function updateConnectedUsersHTTP(connessi) {
            const partecipanti = connessi.filter(c => c.tipo === 'partecipante');

            const contatore = document.getElementById('partecipantiConnessi');
            if (contatore) {
                contatore.textContent = partecipanti.length;
            }

            updateConnectedParticipants(partecipanti);
        }

        function showHTTPFallbackIndicator() {
            // Rimuovi indicatore esistente
            const existing = document.getElementById('httpFallbackIndicator');
            if (existing) existing.remove();

            const indicator = document.createElement('div');
            indicator.id = 'httpFallbackIndicator';
            indicator.innerHTML = `
        <div style="position: fixed; top: 10px; left: 10px; 
                    background: #ed8936; color: white; padding: 10px 15px; 
                    border-radius: 8px; z-index: 1000; font-size: 14px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
            üîÑ Modalit√† HTTP Backup Attiva
        </div>
    `;

            document.body.appendChild(indicator);
        }

        // Carica partecipanti per gestione
        async function caricaPartecipantiPerGestione() {
            try {
                const response = await fetch('/api/debug/partecipanti');
                const data = await response.json();

                const content = document.getElementById('partecipantiGestioneContent');

                if (data.count === 0) {
                    content.innerHTML = '<p>Nessun partecipante registrato</p>';
                    return;
                }

                let html = `
                <div style="margin-bottom: 15px;">
                    <strong>Totale partecipanti: ${data.count}</strong> |
                    <strong>Sessione: ${data.sessione_corrente}</strong>
                </div>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Nome</th>
                            <th>Crediti</th>
                            <th>Giocatori</th>
                            <th>Notifiche</th>
                            <th>Registrato</th>
                            <th>Azioni</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

                data.partecipanti.forEach(p => {
                    const dataRegistrazione = new Date(p.registrato_il).toLocaleDateString('it-IT');
                    html += `
                    <tr id="partecipante-${p.id}">
                        <td><strong>${p.nome}</strong><br><small>${p.id}</small></td>
                        <td>${p.crediti}</td>
                        <td>${p.giocatori_vinti}/10</td>
                        <td>${p.notifiche_attive > 0 ? '‚úÖ' : '‚ùå'}</td>
                        <td>${dataRegistrazione}</td>
                        <td>
                            <button class="btn btn-danger" style="padding: 5px 10px; font-size: 0.8em;"
                                    onclick="eliminaPartecipante('${p.id}', '${p.nome}')"
                                    title="Elimina partecipante">
                                üóëÔ∏è Elimina
                            </button>
                        </td>
                    </tr>
                `;
                });

                html += '</tbody></table>';

                content.innerHTML = html;

            } catch (error) {
                console.error('Errore caricamento partecipanti:', error);
                document.getElementById('partecipantiGestioneContent').innerHTML =
                    '<p style="color: #f56565;">Errore caricamento partecipanti</p>';
            }
        }

        // Elimina partecipante
        async function eliminaPartecipante(partecipanteId, nomePartecipante) {
            if (!confirm(`Eliminare definitivamente il partecipante:\n\n"${nomePartecipante}"\n\nQuesta azione √® irreversibile e canceller√†:\n- Il partecipante dal database\n- Tutte le sue aste\n- Le sue notifiche push\n\nProcedere?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/partecipanti/${partecipanteId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showNotification(`Partecipante "${nomePartecipante}" eliminato`, 'success');

                    // Rimuovi dalla tabella
                    const row = document.getElementById(`partecipante-${partecipanteId}`);
                    if (row) {
                        row.remove();
                    }

                    // Ricarica la lista
                    setTimeout(() => {
                        ricaricaPartecipantiGestione();
                    }, 1000);

                } else {
                    const error = await response.json();
                    showNotification('Errore eliminazione: ' + error.error, 'error');
                }
            } catch (error) {
                console.error('Errore eliminazione partecipante:', error);
                showNotification('Errore di connessione', 'error');
            }
        }

        // Ricarica lista partecipanti
        async function ricaricaPartecipantiGestione() {
            document.getElementById('partecipantiGestioneContent').innerHTML = '<p>Caricamento partecipanti...</p>';
            await caricaPartecipantiPerGestione();
        }

        async function pulisciSubscriptions() {
            try {
                const response = await fetch('/api/clean-subscriptions');
                const result = await response.json();

                if (response.ok) {
                    showNotification(`‚úÖ ${result.deleted} subscription eliminate`, 'success');
                    console.log('üîë Nuova chiave pubblica:', result.newPublicKey);
                } else {
                    showNotification('Errore pulizia subscriptions', 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        function updateConnectedParticipants(partecipanti) {
            // Cerca un elemento per mostrare i partecipanti connessi
            const container = document.getElementById('participantsList') ||
                document.getElementById('connectedUsers') ||
                document.getElementById('partecipantiContainer');

            if (container) {
                container.innerHTML = partecipanti.map(p =>
                    `<div class="participant-item">
                <strong>${p.nome}</strong> 
                <span class="status-online">‚óè Online</span>
             </div>`
                ).join('');
            }
        }

        // CORREZIONE: Carica squadre sempre, anche senza connessi
        async function caricaSquadreInFormazione() {
            try {
                console.log('üîÑ Caricando squadre in formazione...');
                const partecipanti = await fetch('/api/partecipanti').then(r => r.json());
                const container = document.getElementById('squadreInFormazione');
                container.innerHTML = '';
                if (partecipanti.length === 0) {
                    container.innerHTML = '<p>Nessun partecipante registrato</p>';
                    return;
                }
                console.log(`üìä Trovati ${partecipanti.length} partecipanti:`, partecipanti);
                const squadreGrid = document.createElement('div');
                squadreGrid.style.display = 'grid';
                squadreGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(280px, 1fr))';
                squadreGrid.style.gap = '15px';
                squadreGrid.style.maxWidth = '100%';
                squadreGrid.style.overflowX = 'auto';
                // CARICA TUTTE LE SQUADRE, anche se l'utente non √® connesso
                for (const partecipante of partecipanti) {
                    console.log(`üéØ Caricando squadra per: ${partecipante.nome} (ID: ${partecipante.id})`);
                    const squadraCard = await creaCardSquadra(partecipante);
                    squadreGrid.appendChild(squadraCard);
                }
                container.appendChild(squadreGrid);
                console.log('‚úÖ Squadre caricate nel Master');
            } catch (error) {
                console.error('‚ùå Errore caricamento squadre:', error);
                document.getElementById('squadreInFormazione').innerHTML = '<p>Errore caricamento squadre</p>';
            }
        }

        // NUOVA FUNZIONE: Crea card per una squadra
        async function creaCardSquadra(partecipante) {
            const card = document.createElement('div');
            card.style.cssText = `
        background: rgba(255,255,255,0.08);
        border-radius: 15px;
        padding: 15px;
        border: 1px solid rgba(255,255,255,0.1);
        min-height: 400px;
        display: flex;
        flex-direction: column;
    `;

            try {
                console.log(`üîç Caricando squadra per ${partecipante.nome}...`);

                const response = await fetch(`/api/squadra-partecipante/${partecipante.id}`);
                let squadra = [];

                if (response.ok) {
                    const data = await response.json();
                    squadra = Array.isArray(data) ? data : (data.squadra || []);
                    console.log(`‚úÖ Squadra caricata per ${partecipante.nome}:`, squadra);
                } else {
                    console.log(`‚ö†Ô∏è Squadra non ancora formata per ${partecipante.nome}`);
                }

                const giocatoriAcquistati = squadra.length;
                const creditiSpesi = squadra.reduce((sum, g) => sum + (g.costo_finale || 0), 0);
                const creditiRimasti = partecipante.crediti;
                const puntiTotali = squadra.reduce((sum, g) => sum + (g.punti_totali || 0), 0);

                // Header della card
                card.innerHTML = `
            <div style="
                text-align: center;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #4299e1;
            ">
                <h3 style="color: #4299e1; margin: 0; font-size: 1.1em;">${partecipante.nome}</h3>
                <div style="font-size: 0.8em; opacity: 0.8; margin-top: 5px;">
                    ${giocatoriAcquistati}/10 giocatori | üí∞ ${creditiRimasti} | üèÜ ${puntiTotali}pt
                </div>
            </div>

            <div id="squadra-slots-${partecipante.id}" style="
                display: grid;
                grid-template-columns: 1fr;
                gap: 6px;
                flex-grow: 1;
            ">
                <!-- I slots verranno popolati dinamicamente -->
            </div>

            <div style="
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid rgba(255,255,255,0.2);
                font-size: 0.8em;
                text-align: center;
                opacity: 0.8;
            ">
                üí∏ Spesi: ${creditiSpesi} | Rimasti: ${creditiRimasti}
            </div>
        `;

                // Popola i slots delle posizioni
                const slotsContainer = card.querySelector(`#squadra-slots-${partecipante.id}`);
                const posizioni = ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'F1', 'F2', 'F3'];

                posizioni.forEach(pos => {
                    const giocatore = squadra.find(g => g.slot_id && g.slot_id.startsWith(pos + '_'));
                    const slotDiv = document.createElement('div');

                    if (giocatore) {
                        const teamColor = getTeamColorForMaster(giocatore.colore);
                        const textColor = getTextColorForTeamMaster(giocatore.colore);

                        slotDiv.style.cssText = `
                    background: linear-gradient(135deg, ${teamColor}90, ${teamColor}60);
                    border: 2px solid ${teamColor};
                    padding: 8px;
                    border-radius: 8px;
                    text-align: center;
                    font-size: 0.85em;
                    color: ${textColor};
                    font-weight: bold;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                `;

                        slotDiv.innerHTML = `
    <div style="color: ${textColor}; font-weight: bold; margin-bottom: 2px;">${pos}</div>
    <div style="color: ${textColor}; font-size: 0.9em; line-height: 1.2;">${giocatore.giocatore_attuale}</div>
    <div style="color: ${textColor}; font-size: 0.75em; opacity: 0.9; margin-top: 2px;">
        ${giocatore.colore} ‚Ä¢ ${giocatore.costo_finale}‚Ç¨
    </div>
    <div style="color: #48bb78; font-size: 0.75em; font-weight: bold; margin-top: 2px;">
        üéØ ${giocatore.punti_totali || 0}pt
    </div>
`;
                    } else {
                        slotDiv.style.cssText = `
                    background: rgba(74,85,104,0.2);
                    border: 1px dashed #4a5568;
                    padding: 8px;
                    border-radius: 8px;
                    text-align: center;
                    font-size: 0.85em;
                    opacity: 0.5;
                    color: #a0aec0;
                `;

                        slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 2px;">${pos}</div>
                    <div style="font-size: 0.8em;">- disponibile -</div>
                `;
                    }

                    slotsContainer.appendChild(slotDiv);
                });

            } catch (error) {
                card.innerHTML = `
            <div style="text-align: center;">
                <h3 style="color: #4299e1; margin: 0 0 10px 0;">${partecipante.nome}</h3>
                <p style="opacity: 0.7; color: #f56565;">Errore caricamento squadra</p>
                <div style="font-size: 0.9em; opacity: 0.9;">
                    üí∞ Crediti: ${partecipante.crediti}
                </div>
            </div>
        `;
            }

            return card;
        }

        // CORREZIONE: Funzione colori Master con mappatura completa
        function getTeamColorForMaster(nomeColore) {
            const colori = {
                // Colori base - MASCHILI
                'rosso': '#ef4444',
                'blu': '#3b82f6',
                'verde': '#10b981',
                'giallo': '#f59e0b',
                'viola': '#8b5cf6',
                'arancione': '#f97316',
                'rosa': '#ec4899',
                'azzurro': '#06b6d4',
                'marrone': '#92400e',
                'nero': '#374151',
                'bianco': '#f3f4f6',
                'grigio': '#6b7280',
                'lime': '#84cc16',
                'indaco': '#6366f1',
                'fucsia': '#d946ef',

                // NUOVI COLORI PARTICOLARI
                'smeraldo': '#10b981',
                'royal': '#1e40af',
                'ciano': '#06b6d4',
                'bordeaux': '#7c2d12',
                'crema': '#fef3c7',
                'lilla': '#c4b5fd',
                'gialla': '#f59e0b',

                // Colori base - FEMMINILI
                'rossa': '#ef4444',
                'gialla': '#f59e0b',
                'azzurra': '#06b6d4',
                'nera': '#374151',
                'bianca': '#f3f4f6',
                'grigia': '#6b7280',

                // Varianti e sinonimi
                'celeste': '#06b6d4',
                'cielo': '#06b6d4',
                'blu chiaro': '#60a5fa',
                'blu chiara': '#60a5fa',
                'blu scuro': '#1e40af',
                'blu scura': '#1e40af',
                'rosso chiaro': '#f87171',
                'rossa chiara': '#f87171',
                'rosso scuro': '#b91c1c',
                'rossa scura': '#b91c1c',
                'verde chiaro': '#34d399',
                'verde chiara': '#34d399',
                'verde scuro': '#047857',
                'verde scura': '#047857',
                'giallo chiaro': '#fbbf24',
                'gialla chiara': '#fbbf24',
                'giallo scuro': '#d97706',
                'gialla scura': '#d97706',
                'viola chiaro': '#a78bfa',
                'viola chiara': '#a78bfa',
                'viola scuro': '#6d28d9',
                'viola scura': '#6d28d9',
                'arancio': '#f97316',
                'arancione chiaro': '#fb923c',
                'arancione chiara': '#fb923c',
                'arancione scuro': '#ea580c',
                'arancione scura': '#ea580c',
                'rosa chiaro': '#f9a8d4',
                'rosa chiara': '#f9a8d4',
                'rosa scuro': '#be185d',
                'rosa scura': '#be185d',
                'magenta': '#e879f9',
                'turchese': '#14b8a6',
                'oro': '#eab308',
                'dorato': '#eab308',
                'dorata': '#eab308',
                'argento': '#9ca3af',
                'argentato': '#9ca3af',
                'argentata': '#9ca3af',
                'bronzo': '#a16207',
                'beige': '#d6d3d1',
                'lavanda': '#c4b5fd',
                'menta': '#6ee7b7',
                'corallo': '#fb7185',
                'salmone': '#fca5a5',
                'petrolio': '#0f766e',
                'navy': '#1e3a8a',
                'militare': '#365314',
                'sabbia': '#fef3c7',

                // Altri sinonimi femminili
                'azzurra chiara': '#60a5fa',
                'azzurra scura': '#1e40af',
                'celeste chiara': '#60a5fa',
                'celeste scura': '#1e40af',
                'grigia chiara': '#9ca3af',
                'grigia scura': '#4b5563',
                'marrone chiaro': '#d2b48c',
                'marrone chiara': '#d2b48c',
                'marrone scuro': '#8b4513',
                'marrone scura': '#8b4513',
                'nera opaca': '#1f2937',
                'bianca pura': '#ffffff',

                // Colori particolari con varianti
                'fucsia chiara': '#f0abfc',
                'fucsia scura': '#a21caf',
                'magenta chiara': '#f0abfc',
                'magenta scura': '#a21caf',
                'lime chiaro': '#bef264',
                'lime chiara': '#bef264',
                'lime scuro': '#65a30d',
                'lime scura': '#65a30d'
            };

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            // Prima cerca corrispondenza diretta esatta
            if (colori[coloreLowerCase]) {
                console.log(`‚úÖ Master - Colore trovato: "${coloreLowerCase}" ‚Üí ${colori[coloreLowerCase]}`);
                return colori[coloreLowerCase];
            }

            // Poi cerca corrispondenze parziali
            for (const [nome, codice] of Object.entries(colori)) {
                if (coloreLowerCase.includes(nome) || nome.includes(coloreLowerCase)) {
                    console.log(`‚ö†Ô∏è Master - Colore parziale: "${coloreLowerCase}" tramite "${nome}" ‚Üí ${codice}`);
                    return codice;
                }
            }

            // Ultimo resort: genera colore hash
            console.log(`‚ùå Master - Colore non riconosciuto: "${coloreLowerCase}" ‚Üí generando colore casuale`);
            return generaColoreHashMaster(nomeColore);
        }

        // Funzione colore testo per Mobile - Sostituire completamente
        function getTextColorForTeam(nomeColore) {
            // Colori chiari che necessitano testo scuro
            const coloriChiari = [
                'bianco', 'bianca', 'giallo', 'gialla', 'crema', 'lime',
                'giallo chiaro', 'gialla chiara', 'lime chiaro', 'lime chiara',
                'rosa', 'rosa chiaro', 'rosa chiara',
                'celeste', 'azzurro chiaro', 'azzurra chiara',
                'verde chiaro', 'verde chiara', 'viola chiaro', 'viola chiara',
                'arancione chiaro', 'arancione chiara', 'grigio chiaro', 'grigia chiara',
                'argento', 'argentato', 'argentata', 'sabbia', 'beige', 'lavanda',
                'fucsia chiara', 'magenta chiara', 'oro', 'dorato', 'dorata',
                'bianca pura', 'menta'
            ];

            // Colori scuri che necessitano testo bianco
            const coloriScuri = [
                'nero', 'nera', 'blu', 'azzurro', 'azzurra', 'verde', 'verde scuro', 'verde scura',
                'rosso', 'rossa', 'rosso scuro', 'rossa scura', 'viola', 'viola scuro', 'viola scura',
                'marrone', 'marrone scuro', 'marrone scura', 'arancione', 'arancione scuro', 'arancione scura',
                'bordeaux', 'navy', 'militare', 'petrolio', 'indaco', 'blu scuro', 'blu scura',
                'grigio', 'grigia', 'grigio scuro', 'grigia scura', 'bronzo',
                'smeraldo', 'royal', 'ciano', 'turchese', 'fucsia', 'magenta',
                'lime scuro', 'lime scura', 'nera opaca', 'azzurra scura', 'celeste scura'
            ];

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            // Prima controlla se √® esplicitamente un colore chiaro
            const isColoreChiaro = coloriChiari.some(colore =>
                coloreLowerCase === colore || coloreLowerCase.includes(colore) || colore.includes(coloreLowerCase)
            );

            if (isColoreChiaro) {
                return '#1a202c'; // Testo scuro per sfondi chiari
            }

            // Poi controlla se √® esplicitamente un colore scuro
            const isColoreScuro = coloriScuri.some(colore =>
                coloreLowerCase === colore || coloreLowerCase.includes(colore) || colore.includes(coloreLowerCase)
            );

            if (isColoreScuro) {
                return '#ffffff'; // Testo bianco per sfondi scuri
            }

            // Default: testo bianco per colori non riconosciuti
            return '#ffffff';
        }

        // Funzione helper per generare colore hash nel Master
        function generaColoreHashMaster(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }

            const hue = Math.abs(hash) % 360;
            const saturation = 65 + (Math.abs(hash) % 35);
            const lightness = 45 + (Math.abs(hash) % 20);

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // NUOVA FUNZIONE: Determina colore testo ottimale per Master
        function getTextColorForTeamMaster(nomeColore) {
            // Colori chiari che necessitano testo scuro
            const coloriChiari = [
                'bianco', 'bianca', 'giallo', 'gialla', 'crema', 'lime',
                'giallo chiaro', 'gialla chiara', 'lime chiaro', 'lime chiara',
                'rosa', 'rosa chiaro', 'rosa chiara',
                'celeste', 'azzurro chiaro', 'azzurra chiara',
                'verde chiaro', 'verde chiara', 'viola chiaro', 'viola chiara',
                'arancione chiaro', 'arancione chiara', 'grigio chiaro', 'grigia chiara',
                'argento', 'argentato', 'argentata', 'sabbia', 'beige', 'lavanda',
                'fucsia chiara', 'magenta chiara', 'oro', 'dorato', 'dorata',
                'bianca pura', 'menta'
            ];

            // Colori scuri che necessitano testo bianco
            const coloriScuri = [
                'nero', 'nera', 'blu', 'azzurro', 'azzurra', 'verde', 'verde scuro', 'verde scura',
                'rosso', 'rossa', 'rosso scuro', 'rossa scura', 'viola', 'viola scuro', 'viola scura',
                'marrone', 'marrone scuro', 'marrone scura', 'arancione', 'arancione scuro', 'arancione scura',
                'bordeaux', 'navy', 'militare', 'petrolio', 'indaco', 'blu scuro', 'blu scura',
                'grigio', 'grigia', 'grigio scuro', 'grigia scura', 'bronzo',
                'smeraldo', 'royal', 'ciano', 'turchese', 'fucsia', 'magenta',
                'lime scuro', 'lime scura', 'nera opaca', 'azzurra scura', 'celeste scura'
            ];

            const coloreLowerCase = nomeColore.toLowerCase().trim();

            // Prima controlla se √® esplicitamente un colore chiaro
            const isColoreChiaro = coloriChiari.some(colore =>
                coloreLowerCase === colore || coloreLowerCase.includes(colore) || colore.includes(coloreLowerCase)
            );

            if (isColoreChiaro) {
                return '#1a202c'; // Testo scuro per sfondi chiari
            }

            // Poi controlla se √® esplicitamente un colore scuro
            const isColoreScuro = coloriScuri.some(colore =>
                coloreLowerCase === colore || coloreLowerCase.includes(colore) || colore.includes(coloreLowerCase)
            );

            if (isColoreScuro) {
                return '#ffffff'; // Testo bianco per sfondi scuri
            }

            // Default: testo bianco per colori non riconosciuti
            return '#ffffff';
        }

        // Setup event listeners - VERSIONE CORRETTA
        function setupEventListeners() {
            // Selezione round - CON CONTROLLO RAFFORZATO
            document.querySelectorAll('.round-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // CONTROLLO SUPER RAFFORZATO
                    if (btn.classList.contains('completed') ||
                        btn.disabled ||
                        btn.style.pointerEvents === 'none' ||
                        btn.style.opacity === '0.4') {

                        console.log(`‚ùå CLICK BLOCCATO su ${btn.dataset.round} - Round completato`);
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        return false;
                    }

                    // Solo se non √® attivo e non √® disabilitato
                    if (!btn.classList.contains('active') && !btn.disabled) {
                        selectRound(btn.dataset.round);
                    }
                });
            });
        }

        // Gestione round
        function selectRound(round) {
            // Rimuovi selezione precedente
            document.querySelectorAll('.round-btn').forEach(btn => {
                btn.style.outline = 'none';
                btn.style.boxShadow = 'none';
            });

            // Seleziona nuovo round
            const btn = document.querySelector(`[data-round="${round}"]`);
            btn.style.outline = '3px solid #ffd700';
            btn.style.boxShadow = '0 0 15px rgba(255, 215, 0, 0.5)';

            roundSelezionato = round;
            document.getElementById('selectedRoundDisplay').textContent = round;
            document.getElementById('btnAvviaRound').disabled = false;
        }

        async function avviaRound(round) {
            if (gameState.asteAttive) {
                showNotification('Un round √® gi√† attivo!', 'warning');
                return;
            }

            // Conferma avvio
            if (!confirm(`Avviare il round ${round}?\n\nTutti i partecipanti potranno iniziare a fare le loro offerte.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/avvia-round/${round}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // NUOVO: Aggiorna immediatamente lo stato locale
                    gameState.asteAttive = true;
                    gameState.roundAttivo = round;

                    // Aggiorna UI
                    document.querySelector(`[data-round="${round}"]`).classList.remove('available');
                    document.querySelector(`[data-round="${round}"]`).classList.add('active');
                    document.getElementById('btnAvviaRound').disabled = true;
                    document.getElementById('btnFermaRound').disabled = false;
                    updateUI();

                    // Reset selezione e tracciamento offerte
                    roundSelezionato = null;
                    participantsBids.clear();
                    document.getElementById('selectedRoundDisplay').textContent = 'Round in corso...';
                } else {
                    const error = await response.json();
                    showNotification('Errore: ' + error.error, 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        function avviaRoundSelezionato() {
            if (roundSelezionato) {
                avviaRound(roundSelezionato);
            }
        }

        async function forzaFineRound() {
            // NUOVO: Verifica stato dal server prima di procedere
            try {
                const statoResponse = await fetch('/api/stato');
                const statoServer = await statoResponse.json();

                if (!statoServer.asteAttive && !gameState.asteAttive) {
                    showNotification('Nessun round attivo da terminare', 'warning');
                    return;
                }

                // Aggiorna stato locale se necessario
                if (statoServer.asteAttive && !gameState.asteAttive) {
                    console.log('üîÑ Sincronizzando stato locale con server');
                    gameState.asteAttive = true;
                    gameState.roundAttivo = statoServer.roundAttivo;
                    updateUI();
                }

            } catch (error) {
                console.error('Errore verifica stato server:', error);
                // Continua comunque con il tentativo
            }

            if (!confirm('Vuoi terminare il round anche se non tutti hanno fatto offerte?\n\nI partecipanti che non hanno offerto non riceveranno giocatori.')) {
                return;
            }

            try {
                const response = await fetch('/api/forza-fine-round', {
                    method: 'POST'
                });

                if (response.ok) {
                    showNotification('Round terminato forzatamente', 'warning');
                    // NUOVO: Aggiorna immediatamente lo stato locale
                    gameState.asteAttive = false;
                    gameState.roundAttivo = null;
                    updateUI();
                } else {
                    const error = await response.json();
                    showNotification('Errore: ' + (error.error || 'Errore sconosciuto'), 'error');
                }
            } catch (error) {
                console.error('Errore forzatura fine round:', error);
                showNotification('Errore di connessione', 'error');
            }
        }

        // Gestione display offerte (sostituisce timer)
        function startOffersDisplay() {
            document.getElementById('currentRoundInfo').style.display = 'block';
            document.getElementById('activeRoundName').textContent = gameState.roundAttivo;

            // Reset display
            updateOffersDisplay({
                partecipantiConnessi: gameState.connessi.filter(p => p.tipo === 'partecipante').length,
                offerteRicevute: 0,
                mancano: gameState.connessi.filter(p => p.tipo === 'partecipante').length
            });
        }

        function updateOffersDisplay(data) {
            const displayEl = document.getElementById('offersDisplay');
            const messageEl = document.getElementById('offersStatusMessage');

            displayEl.textContent = `${data.offerteRicevute}/${data.partecipantiConnessi}`;

            if (data.mancano > 0) {
                displayEl.style.color = '#f59e0b';
                messageEl.textContent = `Mancano ${data.mancano} offerte per proseguire`;
            } else {
                displayEl.style.color = '#10b981';
                messageEl.textContent = '‚úÖ Tutti hanno offerto! Elaborazione automatica in corso...';
            }
        }

        function updatePartecipantiWithBids(data) {
            // Aggiorna lo stato delle offerte dei partecipanti
            if (data.dettaglioOfferte) {
                data.dettaglioOfferte.forEach(offerta => {
                    participantsBids.set(offerta.partecipante, offerta.offerta);
                });
            }
            updatePartecipanti();
        }

        function stopOffersDisplay() {
            document.getElementById('currentRoundInfo').style.display = 'none';

            // Aggiorna stato round button - MARCA COME COMPLETATO
            if (gameState.roundAttivo) {
                const btn = document.querySelector(`[data-round="${gameState.roundAttivo}"]`);
                if (btn) {
                    btn.classList.remove('active', 'available');
                    btn.classList.add('completed');
                    btn.style.outline = 'none';
                    btn.style.boxShadow = 'none';
                    btn.disabled = true;  // AGGIUNTO: disabilita fisicamente
                    btn.style.opacity = '0.6';
                    btn.style.cursor = 'not-allowed';
                    btn.style.pointerEvents = 'none';
                }
            }

            // Reset selezione e tracciamento
            participantsBids.clear();
            document.getElementById('selectedRoundDisplay').textContent = 'Nessuno';
            document.getElementById('btnAvviaRound').disabled = true;
            document.getElementById('btnFermaRound').disabled = true;
        }

        // Update UI
        function updateUI() {
            updateRoundButtons();
            updateControlButtons();
            updatePartecipanti();
            updateStats();

            // AGGIUNTO: Mantieni stato completed dopo aggiornamenti
            document.querySelectorAll('.round-btn.completed').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.4';  // Opacizzato
                btn.style.pointerEvents = 'none';
                btn.style.cursor = 'not-allowed';
                btn.style.filter = 'grayscale(50%)';  // Bianco e nero
            });
        }

        async function updateRoundButtons() {
            // Prima controlla quali round sono stati completati
            const roundsCompletati = await getRoundsCompletati();

            document.querySelectorAll('.round-btn').forEach(btn => {
                const round = btn.dataset.round;

                // Reset classi
                btn.classList.remove('available', 'active', 'completed');

                if (roundsCompletati.includes(round)) {
                    // Round gi√† completato
                    btn.classList.add('completed');
                    btn.disabled = true;
                    btn.style.opacity = '0.6';
                    btn.style.pointerEvents = 'none';
                    btn.style.cursor = 'not-allowed';
                } else if (round === gameState.roundAttivo && gameState.asteAttive) {
                    // Round attivo
                    btn.classList.add('active');
                } else {
                    // Round non ancora fatto - GRIGIO NEUTRO
                    btn.style.background = '#4a5568';
                    btn.style.color = '#a0aec0';
                    btn.style.borderColor = '#4a5568';
                    btn.style.cursor = 'pointer';
                    btn.disabled = false;
                    btn.style.pointerEvents = 'auto';
                }
            });
        }

        // NUOVA FUNZIONE: Ottieni round completati dal database
        async function getRoundsCompletati() {
            try {
                const rounds = ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'F1', 'F2', 'F3'];
                const completati = [];

                for (const round of rounds) {
                    const response = await fetch(`/api/aste-round/${round}`);
                    if (response.ok) {
                        const aste = await response.json();
                        if (aste.length > 0) {
                            completati.push(round);
                        }
                    }
                }

                console.log('üìä Round completati trovati:', completati);
                return completati;
            } catch (error) {
                console.error('Errore controllo round completati:', error);
                return [];
            }
        }

        function updateControlButtons() {
            document.getElementById('btnAvviaRound').disabled = gameState.asteAttive || !roundSelezionato;
            document.getElementById('btnFermaRound').disabled = !gameState.asteAttive;
        }

        function updatePartecipanti() {
            const container = document.getElementById('participantsContainer');

            const partecipanti = gameState.connessi.filter(p => p.tipo === 'partecipante');
            console.log('üîç Debug partecipanti:', {
                totaleConnessi: gameState.connessi.length,
                partecipantiFiltrati: partecipanti.length,
                dettaglio: gameState.connessi.map(p => ({ nome: p.nome, tipo: p.tipo }))
            });

            if (partecipanti.length === 0) {
                container.innerHTML = '<p>Nessun partecipante connesso</p>';
                return;
            }

            container.innerHTML = '';
            const grid = document.createElement('div');
            grid.className = 'participants-grid';

            partecipanti.forEach(p => {
                const card = document.createElement('div');
                card.className = 'participant-card';

                // Stato della puntata
                let bidStatus = 'Nessuna offerta';
                let bidClass = 'bid-none';

                if (gameState.asteAttive && participantsBids.has(p.nome)) {
                    bidStatus = '‚úÖ Offerta confermata';
                    bidClass = 'bid-confirmed';
                    card.classList.add('bid-confirmed');
                } else if (gameState.asteAttive) {
                    bidStatus = '‚è≥ In attesa...';
                    bidClass = 'bid-pending';
                    card.classList.add('bid-pending');
                }

                card.innerHTML = `
                                <div><strong>${p.nome}</strong></div>
                                <div>Stato: ${p.stato}</div>
                                <div class="bid-status ${bidClass}">${bidStatus}</div>
                            `;

                grid.appendChild(card);
            });

            container.appendChild(grid);
        }

        function updateStats() {
            const connessi = gameState.connessi.filter(p => p.tipo === 'partecipante').length;
            document.getElementById('statConnessi').textContent = connessi;

            const offerte = participantsBids.size;
            document.getElementById('statOfferte').textContent = offerte;

            // TODO: Aggiornare altre statistiche dal database
            document.getElementById('statRounds').textContent = '0';
            document.getElementById('statCrediti').textContent = '0';
        }

        // Risultati e classifiche
        function mostraRisultatiRound(round, risultati) {
            const modal = document.getElementById('resultsModal');
            const title = document.getElementById('resultsTitle');
            const content = document.getElementById('resultsContent');

            title.textContent = `Risultati Round ${round}`;

            let html = '<table class="results-table"><thead><tr>';
            html += '<th>Giocatore</th><th>Vincitore</th><th>Offerta</th><th>Costo Finale</th><th>Condiviso</th>';
            html += '</tr></thead><tbody>';

            // CORREZIONE: Verifica che risultati esista ed √® un array
            if (risultati && Array.isArray(risultati)) {
                risultati.forEach(r => {
                    html += `<tr>
                <td><strong>${r.slot.replace('_', ' ')}</strong></td>
                <td>${r.nome}</td>
                <td>${r.offertaOriginale}</td>
                <td>${r.costoFinale}</td>
                <td>${r.condiviso ? '‚úÖ' : '‚ùå'}</td>
            </tr>`;
                });
            } else {
                html += '<tr><td colspan="5">Nessun risultato disponibile</td></tr>';
            }

            html += '</tbody></table>';
            content.innerHTML = html;
            modal.style.display = 'flex';

            // Aggiorna anche la sezione risultati nella pagina
            document.getElementById('lastRoundResults').innerHTML = `
        <h3>Round ${round} - ${risultati ? risultati.length : 0} assegnazioni</h3>
        ${html}
    `;
        }

        async function mostraClassifica() {
            try {
                console.log('üìä Caricamento classifica su richiesta...');
                const response = await fetch('/api/classifica');
                if (!response.ok) {
                    throw new Error('API non disponibile');
                }

                const classifica = await response.json();

                const modal = document.getElementById('classificaModal');
                const content = document.getElementById('classificaContent');

                let html = '<table class="results-table"><thead><tr>';
                html += '<th>Pos</th><th>Nome</th><th>Punti</th>';
                html += '</tr></thead><tbody>';

                classifica.forEach((p, index) => {
                    html += `<tr>
            <td><strong>${index + 1}¬∞</strong></td>
            <td>${p.nome}</td>
            <td>${p.punti_totali}</td>
        </tr>`;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
                modal.style.display = 'flex';
            } catch (error) {
                showNotification('Classifica non ancora disponibile', 'warning');
            }
        }

        // Strumenti admin
        function vaiASetup() {
            window.location.href = '/setup';
        }

        async function esportaDati() {
            try {
                const response = await fetch('/api/export');
                if (!response.ok) {
                    throw new Error('Export non disponibile');
                }

                const data = await response.json();

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fantagts_export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                showNotification('Dati esportati con successo', 'success');
            } catch (error) {
                showNotification('Export non ancora disponibile', 'warning');
            }
        }

        function resetAste() {
            showConfirmModal(
                'Reset Aste',
                'Questa azione canceller√† tutte le aste e ripristiner√† i crediti. Procedere?',
                async () => {
                    try {
                        const response = await fetch('/api/reset/aste', { method: 'POST' });
                        if (response.ok) {
                            showNotification('Aste resettate con successo', 'success');
                            // NUOVO: Reset UI senza ricaricare la pagina
                            resetPulsantiManuale();
                            caricaSquadreInFormazione(); // Ricarica le squadre
                        } else {
                            showNotification('Errore durante reset', 'error');
                        }
                    } catch (error) {
                        showNotification('Errore di connessione', 'error');
                    }
                }
            );
        }

        function resetPulsantiManuale() {
            document.querySelectorAll('.round-btn').forEach(btn => {
                // RIMUOVI TUTTE LE CLASSI
                btn.classList.remove('active', 'completed', 'available');

                // RIPRISTINA STATO ORIGINALE NEUTRO
                btn.style.background = '#4a5568';
                btn.style.color = '#a0aec0';
                btn.style.borderColor = '#4a5568';
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
                btn.style.filter = 'none';
                btn.style.boxShadow = 'none';
                btn.disabled = false;
                btn.style.pointerEvents = 'auto';
                btn.style.outline = 'none';

                // Reset hover effects
                btn.onmouseover = function () {
                    if (!this.classList.contains('completed') && !this.classList.contains('active')) {
                        this.style.background = '#38a169';
                        this.style.transform = 'translateY(-2px)';
                        this.style.boxShadow = '0 4px 12px rgba(72, 187, 120, 0.4)';
                    }
                };

                btn.onmouseout = function () {
                    if (!this.classList.contains('completed') && !this.classList.contains('active')) {
                        this.style.background = '#4a5568';
                        this.style.transform = 'none';
                        this.style.boxShadow = 'none';
                    }
                };
            });

            // Reset selezione
            roundSelezionato = null;
            document.getElementById('selectedRoundDisplay').textContent = 'Nessuno';
            document.getElementById('btnAvviaRound').disabled = true;
            document.getElementById('btnFermaRound').disabled = true;

            // Reset display round attivo
            document.getElementById('currentRoundInfo').style.display = 'none';

            // Reset statistiche
            document.getElementById('statRounds').textContent = '0';
            document.getElementById('statCrediti').textContent = '0';

            console.log('üîÑ Pulsanti ripristinati allo stato originale uniforme');
        }

        function resetTotale() {
            showConfirmModal(
                'Reset Totale',
                'ATTENZIONE: Questa azione canceller√† TUTTI i dati del sistema. √à irreversibile!',
                async () => {
                    try {
                        const response = await fetch('/api/reset/totale', { method: 'POST' });
                        if (response.ok) {
                            showNotification('Sistema resettato completamente', 'success');
                            setTimeout(() => window.location.href = '/setup', 2000);
                        } else {
                            showNotification('Errore durante reset', 'error');
                        }
                    } catch (error) {
                        showNotification('Errore di connessione', 'error');
                    }
                }
            );
        }

        // Carica info sessione corrente
        async function caricaInfoSessione() {
            try {
                const response = await fetch('/api/sessione-info');
                const sessionInfo = await response.json();

                document.getElementById('currentSession').textContent =
                    sessionInfo.sessione_descrizione || `Anno ${sessionInfo.sessione_anno || 'Non definito'}`;

                if (sessionInfo.sessione_data_inizio) {
                    const date = new Date(sessionInfo.sessione_data_inizio);
                    document.getElementById('sessionDate').textContent = date.toLocaleDateString('it-IT');
                }

            } catch (error) {
                console.error('Errore caricamento info sessione:', error);
                document.getElementById('currentSession').textContent = 'Errore caricamento';
            }
        }

        // Mostra modal pulisci test
        async function mostraPulisciTest() {
            try {
                const response = await fetch('/api/partecipanti');
                const partecipanti = await response.json();

                const container = document.getElementById('participantsList');
                container.innerHTML = '';

                if (partecipanti.length === 0) {
                    container.innerHTML = '<p>Nessun partecipante registrato</p>';
                } else {
                    partecipanti.forEach(p => {
                        const div = document.createElement('div');
                        div.style.cssText = 'padding: 10px; margin: 5px 0; background: rgba(255,255,255,0.1); border-radius: 5px;';
                        div.innerHTML = `
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" value="${p.id}" style="margin-right: 10px;">
                                <span><strong>${p.nome}</strong> - Crediti: ${p.crediti}</span>
                            </label>
                        `;
                        container.appendChild(div);
                    });
                }

                document.getElementById('pulisciTestModal').style.display = 'flex';
            } catch (error) {
                showNotification('Errore caricamento partecipanti', 'error');
            }
        }

        // Esegui pulizia test
        async function eseguiPuliziaTest() {
            const checkboxes = document.querySelectorAll('#participantsList input[type="checkbox"]:checked');
            const mantieni = Array.from(checkboxes).map(cb => cb.value);

            if (!confirm(`Eliminare tutti i partecipanti tranne ${mantieni.length} selezionati?`)) {
                return;
            }

            try {
                const response = await fetch('/api/pulisci-test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mantieni: mantieni })
                });

                if (response.ok) {
                    showNotification('Dati di test puliti con successo!', 'success');
                    closeModal('pulisciTestModal');
                    setTimeout(() => location.reload(), 1000);
                } else {
                    const error = await response.json();
                    showNotification('Errore: ' + error.error, 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        // Elimina tutti i partecipanti
        async function eliminaTuttiPartecipanti() {
            if (!confirm('ATTENZIONE: Eliminare TUTTI i partecipanti? Questa azione √® irreversibile!')) {
                return;
            }

            try {
                const response = await fetch('/api/pulisci-test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mantieni: [] })
                });

                if (response.ok) {
                    showNotification('Tutti i partecipanti eliminati', 'success');
                    closeModal('pulisciTestModal');
                    setTimeout(() => location.reload(), 1000);
                } else {
                    showNotification('Errore durante eliminazione', 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        // Mostra modal nuova sessione
        function mostraNuovaSessione() {
            const currentYear = new Date().getFullYear();
            document.getElementById('nuovoAnno').value = currentYear;
            document.getElementById('nuovaDescrizione').value = `FantaGTS ${currentYear}`;
            document.getElementById('nuovaSessioneModal').style.display = 'flex';
        }

        // Crea nuova sessione
        async function creaNuovaSessione() {
            const anno = document.getElementById('nuovoAnno').value;
            const descrizione = document.getElementById('nuovaDescrizione').value;

            if (!anno) {
                alert('Inserisci un anno valido');
                return;
            }

            if (!confirm(`Creare una nuova sessione per l'anno ${anno}?\n\nI dati attuali verranno salvati come backup e il sistema verr√† resettato.`)) {
                return;
            }

            try {
                const response = await fetch('/api/nuova-sessione', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ anno: anno, descrizione: descrizione })
                });

                if (response.ok) {
                    const result = await response.json();
                    showNotification(result.message, 'success');
                    closeModal('nuovaSessioneModal');

                    if (result.redirectTo) {
                        setTimeout(() => window.location.href = result.redirectTo, 2000);
                    }
                } else {
                    const error = await response.json();
                    showNotification('Errore: ' + error.error, 'error');
                }
            } catch (error) {
                showNotification('Errore di connessione', 'error');
            }
        }

        // Mostra lista backup (placeholder)
        function mostraBackupList() {
            document.getElementById('backupContent').innerHTML = `
                <p>Funzionalit√† di visualizzazione backup in sviluppo.</p>
                <p>I backup vengono salvati automaticamente nel database quando crei una nuova sessione.</p>
                <p>Le tabelle di backup seguono il formato: <code>tabella_backup_ANNO_TIMESTAMP</code></p>
            `;
            document.getElementById('backupListModal').style.display = 'flex';
        }

        // Utilities
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function showConfirmModal(title, message, onConfirm) {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmBtn').onclick = () => {
                closeModal('confirmModal');
                onConfirm();
            };
            document.getElementById('confirmModal').style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Salvataggio automatico ogni 30 secondi quando ci sono cambiamenti
        setInterval(async () => {
            if (gameState.asteAttive || document.querySelectorAll('.team-slot.filled').length > 0) {
                await saveMasterState();
            }
        }, 30000);

        // Salva stato quando si chiude la finestra
        window.addEventListener('beforeunload', () => {
            saveMasterState();
        });

    </script>

    <!-- PWA Registration -->
    <script>
        // Registrazione Service Worker (versione semplificata per Master/Setup)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => console.log('‚úÖ SW registrato:', registration.scope))
                .catch(error => console.log('‚ùå Errore SW:', error));
        }
    </script>

</body>
</html>